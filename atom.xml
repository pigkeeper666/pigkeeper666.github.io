<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>养猪大师</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-21T07:07:05.046Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>循环输出问题</title>
    <link href="http://yoursite.com/2020/05/21/%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/05/21/%E5%BE%AA%E7%8E%AF%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-21T06:44:52.000Z</published>
    <updated>2020-05-21T07:07:05.046Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这几天写项目的时候遇到了一些问题，比如说有一个循环&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;( xxx )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xxxx&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;循环体的内容是触发一个动画，需求是上一个动画结束以后才可以进入下一个循环&lt;/p&gt;
&lt;p&gt;也就是说不能抢跑。&lt;/p&gt;
&lt;h2 id=&quot;抽象&quot;&gt;&lt;a href=&quot;#抽象&quot; class=&quot;headerlink&quot; title=&quot;抽象&quot;&gt;&lt;/a&gt;抽象&lt;/h2&gt;&lt;p&gt;抽象一下，大概可以理解成这样一个问题&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;; i ++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;timer&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;number&quot;&gt;1000&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样子是会全部输出6的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,此时循环已经结束，i变成了6。因此会全部输出6。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;p&gt;1、有没有办法让他输出1，2，3，4，5？&lt;/p&gt;
&lt;p&gt;2、在满足上一条的同时，有没有办法让他这样输出：1 …隔一秒… 2 …隔一秒… 3 …&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>品字布局与圣杯布局</title>
    <link href="http://yoursite.com/2020/05/20/%E5%93%81%E5%AD%97%E5%B8%83%E5%B1%80%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2020/05/20/%E5%93%81%E5%AD%97%E5%B8%83%E5%B1%80%E4%B8%8E%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/</id>
    <published>2020-05-20T15:30:53.000Z</published>
    <updated>2020-05-20T15:52:48.830Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文将通过css flex来进行常见的布局（品字型布局与圣杯布局）&lt;/p&gt;
&lt;h2 id=&quot;品字布局&quot;&gt;&lt;a href=&quot;#品字布局&quot; class=&quot;headerlink&quot; title=&quot;品字布局&quot;&gt;&lt;/a&gt;品字布局&lt;/h2&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx2.sbimg.cn/2020/05/20/-2020-05-20-233311.png&quot; alt=&quot;-2020-05-20-233311.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;红色部分的是header，高度为定高（80px），模拟的是顶部导航条&lt;/p&gt;
&lt;p&gt;绿色部分的是left，宽度可以定死也可以自适应，模拟的是左侧导航条。&lt;/p&gt;
&lt;p&gt;黄色部分的是right，宽度可以定死也可以自适应，模拟的是主要内容区域。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>RESTful</title>
    <link href="http://yoursite.com/2020/05/19/RESTful/"/>
    <id>http://yoursite.com/2020/05/19/RESTful/</id>
    <published>2020-05-19T15:11:28.000Z</published>
    <updated>2020-05-19T15:27:19.535Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 参考文章：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/30396391&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/30396391&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/28557115&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/28557115&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;REST :REpresentational State Transfer 直接翻译：表现层状态转移&lt;br&gt;首先，之所以晦涩是因为前面主语被去掉了，全称是 Resource Representational State Transfer通俗来讲就是：资源在网络中以某种表现形式进行状态转移。分解开来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resource：资源，即数据（前面说过网络的核心）。比如 newsfeed，friends等&lt;/li&gt;
&lt;li&gt;Representational：某种表现形式，比如用JSON，XML，JPEG等；&lt;/li&gt;
&lt;li&gt;State Transfer：状态变化。通过HTTP动词实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一句很精辟的概括是：&lt;strong&gt;URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RESTful只是一种“规范”，关键是要如何设计好RESTful API&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="RESTful" scheme="http://yoursite.com/tags/RESTful/"/>
    
  </entry>
  
  <entry>
    <title>typeof + instanceof实现</title>
    <link href="http://yoursite.com/2020/05/18/typeof-instanceof%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/05/18/typeof-instanceof%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-05-18T12:21:11.000Z</published>
    <updated>2020-05-18T12:47:01.072Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;typeof和instanceof常用来判断一个变量是什么类型的。本篇会说明两者的区别并手写一个instanceof&lt;/p&gt;
&lt;h2 id=&quot;typeof&quot;&gt;&lt;a href=&quot;#typeof&quot; class=&quot;headerlink&quot; title=&quot;typeof&quot;&gt;&lt;/a&gt;typeof&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于typeof来说，只返回以下几个结果：&lt;code&gt;number&lt;/code&gt;、&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;function&lt;/code&gt;、&lt;code&gt;object&lt;/code&gt;、&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意&lt;code&gt;function&lt;/code&gt;这种引用类型是会返回&lt;code&gt;function&lt;/code&gt;的，并不会返回&lt;code&gt;Object&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于其他的引用类型参数，时终返回&lt;code&gt;object&lt;/code&gt;。&lt;strong&gt;这一点导致无法判断准确的类型&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; arr = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; arr &lt;span class=&quot;comment&quot;&gt;// &quot;object&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; date = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Date&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; date &lt;span class=&quot;comment&quot;&gt;// &quot;object&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS的隐式类型转换</title>
    <link href="http://yoursite.com/2020/05/17/JS%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/05/17/JS%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2020-05-17T09:48:26.000Z</published>
    <updated>2020-05-17T09:50:27.560Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;主要参考：&lt;a href=&quot;https://juejin.im/post/5a7172d9f265da3e3245cbca&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/post/5a7172d9f265da3e3245cbca&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;JS数据类型&quot;&gt;&lt;a href=&quot;#JS数据类型&quot; class=&quot;headerlink&quot; title=&quot;JS数据类型&quot;&gt;&lt;/a&gt;JS数据类型&lt;/h2&gt;&lt;p&gt;js中有7种数据类型，可以分为两类：原始类型、对象类型：&lt;/p&gt;
&lt;p&gt;基础类型(原始值)：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Undefined、 Null、 String、 Number、 Boolean、 Symbol (es6新出的，本文不讨论这种类型)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;复杂类型(对象值)：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;object&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;三种隐式转换&quot;&gt;&lt;a href=&quot;#三种隐式转换&quot; class=&quot;headerlink&quot; title=&quot;三种隐式转换&quot;&gt;&lt;/a&gt;三种隐式转换&lt;/h2&gt;&lt;p&gt;涉及隐式转换最多的两个运算符 + 和 ==。&lt;/p&gt;
&lt;p&gt;+运算符即可数字相加，也可以字符串相加。所以转换时很麻烦。&lt;/p&gt;
&lt;p&gt;== 不同于===，故也存在隐式转换。&lt;/p&gt;
&lt;p&gt;*- / 这些运算符只会针对number类型，故转换的结果只能是转换成number类型。&lt;/p&gt;
&lt;p&gt;那么转换的规则到底是什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐式转换主要涉及三种转换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、将值转为原始值，ToPrimitive()&lt;/p&gt;
&lt;p&gt;2、将值转为数字，ToNumber()&lt;/p&gt;
&lt;p&gt;3、将值转为数字，ToString()&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>css/js/媒体资源会阻塞HTML的解析吗?</title>
    <link href="http://yoursite.com/2020/05/15/css-js-%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90%E4%BC%9A%E9%98%BB%E5%A1%9EHTML%E7%9A%84%E8%A7%A3%E6%9E%90%E5%90%97/"/>
    <id>http://yoursite.com/2020/05/15/css-js-%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90%E4%BC%9A%E9%98%BB%E5%A1%9EHTML%E7%9A%84%E8%A7%A3%E6%9E%90%E5%90%97/</id>
    <published>2020-05-15T06:33:59.000Z</published>
    <updated>2020-05-21T07:13:56.677Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近有复习到浏览器对CSS、JS、媒体资源文件（图片、音频等）的加载和解析。&lt;/p&gt;
&lt;p&gt;当我们解析HTML的时候，遇到上述资源，会不会阻塞HTML解析呢？&lt;/p&gt;
&lt;h2 id=&quot;浏览器渲染流程&quot;&gt;&lt;a href=&quot;#浏览器渲染流程&quot; class=&quot;headerlink&quot; title=&quot;浏览器渲染流程&quot;&gt;&lt;/a&gt;浏览器渲染流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://wx1.sbimg.cn/2020/05/21/3987507-1bfba2f13098339f.jpg&quot; alt=&quot;3987507-1bfba2f13098339f.jpg&quot;&gt;]&lt;/p&gt;
&lt;p&gt;1、&lt;strong&gt;解析HTML生成DOM树&lt;/strong&gt;：渲染引擎首先解析HTML文档，生成DOM树&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;生成CSSOM树&lt;/strong&gt;：无论是内联式、外联是还是嵌入式引入的css样式都会被解析生成CSSOM树。注意，&lt;strong&gt;该步操作与步骤一是并行的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;构建Render树&lt;/strong&gt;：根据DOM树与CSSOM树生成另一颗用于渲染的Render树。&lt;/p&gt;
&lt;p&gt;4、&lt;strong&gt;布局Render树&lt;/strong&gt;：然后对渲染树的每个节点进行布局处理，确定再屏幕上显示的位置。当然这一步还包括一些合成层的操作（新建图层处理一些特殊样势，比如说透明度、transform这种）。&lt;/p&gt;
&lt;p&gt;5、&lt;strong&gt;绘制Render树&lt;/strong&gt;：绘制出一个个节点&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>别再用对象代替Map了</title>
    <link href="http://yoursite.com/2020/05/14/%E5%88%AB%E5%86%8D%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%BB%A3%E6%9B%BFMap%E4%BA%86/"/>
    <id>http://yoursite.com/2020/05/14/%E5%88%AB%E5%86%8D%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%BB%A3%E6%9B%BFMap%E4%BA%86/</id>
    <published>2020-05-14T14:47:39.000Z</published>
    <updated>2020-05-14T15:06:20.656Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实没有标题那么夸张，大家根据喜欢与熟练程度自己选用就好。&lt;/p&gt;
&lt;p&gt;只是今天博主用对象代替Map被坑了，所以决心再也不偷懒了……&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;其实JS里的对象和Map都可以用来存键值对。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;养猪大师&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     num:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; map = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Map&lt;/span&gt;()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.set(&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;养猪大师&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.set(&lt;span class=&quot;string&quot;&gt;&#39;num&#39;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;然而有区别，虽然存的都是key-value，但是在对象中，key的类型会被转化为&lt;strong&gt;字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是map的key值不会被转换哦&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同样，我们也可以通过方法，判断容器里是否有某个key&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(obj[name])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;  &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.has(&lt;span class=&quot;string&quot;&gt;&#39;name&#39;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;map.has(&lt;span class=&quot;string&quot;&gt;&#39;num&#39;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;但是细心的你有没有发现，我少写了一个&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(obj[num])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;你猜猜会输出啥？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Map" scheme="http://yoursite.com/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC的三种架构</title>
    <link href="http://yoursite.com/2020/05/13/WebRTC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2020/05/13/WebRTC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9E%B6%E6%9E%84/</id>
    <published>2020-05-13T12:09:57.000Z</published>
    <updated>2020-05-21T07:20:47.917Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yiyi17/p/12076657.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yiyi17/p/12076657.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yjmyzz/p/webrtc-multiparty-call-architecture.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yjmyzz/p/webrtc-multiparty-call-architecture.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;疑问&quot;&gt;&lt;a href=&quot;#疑问&quot; class=&quot;headerlink&quot; title=&quot;疑问&quot;&gt;&lt;/a&gt;疑问&lt;/h2&gt;&lt;p&gt;WebRTC 本身提供的是&lt;strong&gt;1 对 1&lt;/strong&gt; 的通信模型，在 STUN/TURN 的辅助下，如果能实现 NAT 穿越，那么两个浏览器是可以直接进行媒体数据交换的；如果不能实现 NAT 穿越，那么只能通过 TURN 服务器进行数据转发的方式实现通信。目前来看，Google 开源的用于学习和研究的项目基本都是基于 STUN/TURN 的 1 对 1 通信。&lt;/p&gt;
&lt;p&gt;一些多人场景中，倘若想实现多对多，那怎么办？&lt;/p&gt;
&lt;h2 id=&quot;Mesh架构&quot;&gt;&lt;a href=&quot;#Mesh架构&quot; class=&quot;headerlink&quot; title=&quot;Mesh架构&quot;&gt;&lt;/a&gt;Mesh架构&lt;/h2&gt;&lt;p&gt;最容易想到的便是，对于多人会议中的每个人，都与剩余的人进行P2P的连接。如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx2.sbimg.cn/2020/05/21/-2020-05-13-201611.png&quot; alt=&quot;-2020-05-13-201611.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="WebRTC" scheme="http://yoursite.com/tags/WebRTC/"/>
    
  </entry>
  
  <entry>
    <title>Vue.nextTick</title>
    <link href="http://yoursite.com/2020/05/12/Vue-nextTick/"/>
    <id>http://yoursite.com/2020/05/12/Vue-nextTick/</id>
    <published>2020-05-12T07:40:30.000Z</published>
    <updated>2020-05-21T07:17:47.579Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要参考了博客&lt;a href=&quot;https://segmentfault.com/a/1190000012861862&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000012861862&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;并解决了自己在使用vue中遇到的问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;定义与疑问&quot;&gt;&lt;a href=&quot;#定义与疑问&quot; class=&quot;headerlink&quot; title=&quot;定义与疑问&quot;&gt;&lt;/a&gt;定义与疑问&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Vue.nextTick()的定义如下：&lt;/p&gt;
&lt;p&gt;在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们不禁带着以下疑问：&lt;/p&gt;
&lt;p&gt;1、DOM更新循环是什么？&lt;/p&gt;
&lt;p&gt;2、下次更新循环是什么时候？&lt;/p&gt;
&lt;p&gt;3、什么时候会用到？（也就是为什么我们要延迟回调）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>认清Token的职责</title>
    <link href="http://yoursite.com/2020/05/11/%E8%AE%A4%E6%B8%85Token%E7%9A%84%E8%81%8C%E8%B4%A3/"/>
    <id>http://yoursite.com/2020/05/11/%E8%AE%A4%E6%B8%85Token%E7%9A%84%E8%81%8C%E8%B4%A3/</id>
    <published>2020-05-11T09:26:19.000Z</published>
    <updated>2020-05-21T07:26:00.346Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Session-Cookie&quot;&gt;&lt;a href=&quot;#Session-Cookie&quot; class=&quot;headerlink&quot; title=&quot;Session+Cookie&quot;&gt;&lt;/a&gt;Session+Cookie&lt;/h2&gt;&lt;p&gt;我们知道，http是无状态的，但是在应用中我们常常需要保留用户的登陆状态，也就是保持会话。&lt;/p&gt;
&lt;p&gt;一般我们采取的方案是cookie+session这一套，具体过程不再赘述，总结几点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、cookie的作用域是domain本身以及domain下的所有子域名。也就是说客户端代码和服务器代码运行在同一台服务器上比较好使用，因为cookie是不能跨域名的！！&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;test1.demo.com:8080 与 http:&amp;#x2F;&amp;#x2F;test2.demo.com:8081 之间共享 cookie&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注意：test1.demo.com 是 demo.com的子域名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、服务器端session存在哪？内存还是数据库？当存在内存中时，服务器采用了多台机器负载均衡，怎么办？可以共享内存吗？其次万一服务器这边重启了session会消失吧！当存在数据库中，那么当用户量大的时候，数据库的负担会遍大，同时也需要频繁的读写。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、可能会遭到CSRF攻击（cookie劫持）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对上面三个问题，我们可以想想如何解决：&lt;/p&gt;
&lt;p&gt;1、用token，可以跨域名。&lt;/p&gt;
&lt;p&gt;2、能不能不把session存在服务端，而存在客户端呢？&lt;/p&gt;
&lt;p&gt;3、不使用cookie了，不就能避免CSRF了嘛？&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Token" scheme="http://yoursite.com/tags/Token/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载与防抖节流</title>
    <link href="http://yoursite.com/2020/05/10/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>http://yoursite.com/2020/05/10/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2020-05-10T11:06:17.000Z</published>
    <updated>2020-05-19T15:33:07.757Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;图片懒加载是一种比较常见的优化方式，其效果是当用户拉动滚动条到图片位置时，图片才开始加载（未加载之前会用一张默认图片代替），这样可以有效地防止所有图片集中请求加载，造成拥堵。&lt;/p&gt;
&lt;p&gt;下图是建议的效果，当拉动滚动条到当前加载的图片的最后一张时，会发现下一张还未加载。&lt;/p&gt;
&lt;p&gt;然而继续往下拉动后，这张图片会进行加载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wx1.sbimg.cn/2020/05/19/-2020-05-19-233124.png&quot; alt=&quot;-2020-05-19-233124.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="图片懒加载 节流 防抖" scheme="http://yoursite.com/tags/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD-%E8%8A%82%E6%B5%81-%E9%98%B2%E6%8A%96/"/>
    
  </entry>
  
  <entry>
    <title>如何求解async await promise setTimeout的顺序？</title>
    <link href="http://yoursite.com/2020/05/09/%E5%A6%82%E4%BD%95%E6%B1%82%E8%A7%A3async-await-promise-setTimeout%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F/"/>
    <id>http://yoursite.com/2020/05/09/%E5%A6%82%E4%BD%95%E6%B1%82%E8%A7%A3async-await-promise-setTimeout%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F/</id>
    <published>2020-05-09T12:30:00.000Z</published>
    <updated>2020-05-19T15:35:33.536Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前端笔试题中常常有一种题，给定一定代码，让笔试者写这段代码的输出。一般这段代码，尝尝糅合了各种异步操作，比如async、await、promise、setTimeout，常常令人混淆。与此同时，由于node环境与浏览器环境执行这些异步操作的策略不同，也会有一些差异。&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;重要概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先我们要知道Javascript是&lt;strong&gt;单线程&lt;/strong&gt;的&lt;/li&gt;
&lt;li&gt;Javascript里的代码可以分为&lt;strong&gt;同步任务&lt;/strong&gt;与&lt;strong&gt;异步任务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;同步任务会在&lt;strong&gt;主线程&lt;/strong&gt;上执行。是在栈中执行，先进后出。&lt;/li&gt;
&lt;li&gt;而异步任务会被放置到主线程之外的&lt;strong&gt;任务队列&lt;/strong&gt;，先进先出&lt;/li&gt;
&lt;li&gt;当主线程上的同步任务执行完成后，会读取任务队列的异步任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;宏任务与微任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面讲到异步任务会在任务队列中执行。而执行异步代码的时候会分为两个队列，宏任务队列与微任务队列。&lt;/p&gt;
&lt;p&gt;宏任务包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一开始执行的整段的代码（script代码）&lt;/li&gt;
&lt;li&gt;setTimeout、setInterval、postMessage等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;微任务包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Promise.then后面的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;await后面的代码（指的是 await func() 下一行开始的代码）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;process.nextTick（node中的）&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="异步" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>纯JS瀑布流效果与动态加载</title>
    <link href="http://yoursite.com/2020/05/09/%E7%80%91%E5%B8%83%E6%B5%81%E6%95%88%E6%9E%9C/"/>
    <id>http://yoursite.com/2020/05/09/%E7%80%91%E5%B8%83%E6%B5%81%E6%95%88%E6%9E%9C/</id>
    <published>2020-05-09T01:06:04.000Z</published>
    <updated>2020-05-19T15:41:27.188Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;瀑布流效果的特征是，里面的图片&lt;strong&gt;等宽不等高&lt;/strong&gt;，并按列向下排列。同时，也可以拥有&lt;strong&gt;动态加载&lt;/strong&gt;的功能。&lt;/p&gt;
&lt;p&gt;可以参考&lt;a href=&quot;https://www.mogu.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蘑菇街&lt;/a&gt;首页的效果&lt;/p&gt;
&lt;p&gt;在社区中也有许多的瀑布流库可以使用，本文主要采用&lt;strong&gt;纯JS&lt;/strong&gt;实现。&lt;/p&gt;
&lt;h1 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h1&gt;&lt;p&gt;主要是通过&lt;strong&gt;绝对布局&lt;/strong&gt;的方法对每一个图片盒子进行定位，通过JS计算出每一张图片对应的&lt;strong&gt;left和top属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计算出每一个图片盒子的定位后，通过监听&lt;strong&gt;滚轮事件&lt;/strong&gt;，&lt;strong&gt;判断&lt;/strong&gt;是否要进行动态加载新的图片&lt;/p&gt;
&lt;h1 id=&quot;步骤&quot;&gt;&lt;a href=&quot;#步骤&quot; class=&quot;headerlink&quot; title=&quot;步骤&quot;&gt;&lt;/a&gt;步骤&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;首先搭建基本的html结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下就是一个图片盒子的基本单元，我们复制40次这个单元以充满首屏。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;box&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;./images/0.jpg&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;alt&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
      <category term="瀑布流 JS" scheme="http://yoursite.com/tags/%E7%80%91%E5%B8%83%E6%B5%81-JS/"/>
    
  </entry>
  
  <entry>
    <title>开篇！初心与目标</title>
    <link href="http://yoursite.com/2020/05/08/%E5%BC%80%E7%AF%87%EF%BC%81%E5%88%9D%E5%BF%83%E4%B8%8E%E7%9B%AE%E6%A0%87/"/>
    <id>http://yoursite.com/2020/05/08/%E5%BC%80%E7%AF%87%EF%BC%81%E5%88%9D%E5%BF%83%E4%B8%8E%E7%9B%AE%E6%A0%87/</id>
    <published>2020-05-08T08:47:00.000Z</published>
    <updated>2020-05-08T11:05:49.913Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;建立此博客的目的是为了记录一些平常学习中的所学所感。&lt;/p&gt;
&lt;h1 id=&quot;Flag&quot;&gt;&lt;a href=&quot;#Flag&quot;
        
      
    
    </summary>
    
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
