<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图片懒加载与防抖节流</title>
    <url>/2020/05/10/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>图片懒加载是一种比较常见的优化方式，其效果是当用户拉动滚动条到图片位置时，图片才开始加载（未加载之前会用一张默认图片代替），这样可以有效地防止所有图片集中请求加载，造成拥堵。</p>
<p>下图是建议的效果，当拉动滚动条到当前加载的图片的最后一张时，会发现下一张还未加载。</p>
<p>然而继续往下拉动后，这张图片会进行加载</p>
<p><img src="https://wx2.sbimg.cn/2020/05/10/MDTCPC1OMCGBM_WHPX.png" alt="MDTCPC1OMCGBM_WHPX.png"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>其实主要的思想与我之前的文章<a href="https://www.pigkeeper.xyz/2020/05/09/瀑布流效果/" target="_blank" rel="noopener">纯JS瀑布流效果与动态加载</a>里的动态加载非常的相似，都是计算一个滚动的阈值，达到这个阈值后便进行图片的加载。</p>
<p><strong>首先我们搭建简单的html结构</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，img的src属性都是”./default.png”，这是一张默认图，也就是上图的蓝色图片，而图片真正的src存在data-src中。data-src是一个自定义的数据，当我们获取到某个img的dom节点对象时，我们可以通过一些语句来获得data-src的值，方法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(img.dataset.src)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会输出data-src的内容</span></span><br></pre></td></tr></table></figure>

<p><strong>其次是css</strong></p>
<p>这里只是限定图片的大小，并居中显示</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        <span class="selector-tag">img</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">230px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">320px</span>;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.box</span> &#123;</span><br><span class="line">            <span class="attribute">display</span>: flex;</span><br><span class="line">            <span class="attribute">flex-direction</span>: column;</span><br><span class="line">            <span class="attribute">align-items</span>: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>js部分</strong></p>
<p>至此，我们很容易的想到，如果要实现图片的懒加载，我们只需要监听滚动事件，当触发某个条件时，我们就把img标签的src属性值替换为data-src的值，这样就能加载图片了。</p>
<p>那么，这个条件是什么呢？</p>
<p>同样用一张图来说明：</p>
<p><img src="https://wx2.sbimg.cn/2020/05/10/1.png" alt="1.png"></p>
<p>其中offsetTop、halfHeight、clientHeight都不会变，只有scrollTop会变</p>
<p>故当<strong>offsetTop + halfHeight &lt; scrollTop + clientHeight</strong>时，加载图片。</p>
<p><strong>以下是完整代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有的img节点</span></span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span><br><span class="line">    <span class="comment">// 将伪数组转化为数组</span></span><br><span class="line">    img = [...img]</span><br><span class="line">    img.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 图片高度的一半</span></span><br><span class="line">        <span class="keyword">let</span> halfHeight = <span class="built_in">Math</span>.floor(element.clientHeight / <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (element.offsetTop + halfHeight &lt; <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">            <span class="comment">// 替换src</span></span><br><span class="line">            element.src = element.dataset.src</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>至此，基本完成了图片的懒加载。</p>
<h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><blockquote>
<p> 在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p>
<p>一般可以用防抖和节流来解决这个问题。</p>
</blockquote>
<p><strong>防抖（debounce）</strong></p>
<p><strong>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间，用定时器实现。</strong></p>
<p>下面是具体的实现，注意看我的注释。闭包是为了保留timer这个状态，而apply的作用在注释中有写到，可以仔细去品味一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 闭包</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// !!!!很重要</span></span><br><span class="line">    <span class="comment">// 这个函数是事件对象调用的函数，事件会给这个函数一个参数e 下面可以用arguments拿到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            clearInterval(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 由于是箭头函数，这个this和arguments是从上面继承下来的</span></span><br><span class="line">            <span class="comment">// 用apply是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。</span></span><br><span class="line">            <span class="comment">// 这个arguments就是 e</span></span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>节流（throttle）</strong></p>
<p><strong>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。</strong></p>
<p>懂了防抖，节流也会相对容易理解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">return</span></span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载的优化"><a href="#图片懒加载的优化" class="headerlink" title="图片懒加载的优化"></a>图片懒加载的优化</h2><p>上面我们实现的懒加载，是依靠监听滚动条。当我们滚动时，会频繁的触发计算，是否可以优化，让它少触发几次？那我们是应该用防抖还是节流呢？</p>
<p>想一下，如果用防抖，会导致一直触发事件，一直重置定时器，是不是有可能一直加载不出图片？</p>
<p>而用节流，无论你在这段时间里触发多少次，过了这段时间我一定会执行一次，这是不是就满足了我们的需求！</p>
<p>注意书写形式</p>
<p><strong>完整代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动条用节流比较好</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span><br><span class="line">    <span class="comment">// console.log(img)</span></span><br><span class="line">    img = [...img]</span><br><span class="line">    img.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> halfHeight = <span class="built_in">Math</span>.floor(element.clientHeight / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (element.offsetTop + halfHeight &lt; <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">            element.src = element.dataset.src</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/c8b86b09daf0" target="_blank" rel="noopener">https://www.jianshu.com/p/c8b86b09daf0</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>图片懒加载 节流 防抖</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇！初心与目标</title>
    <url>/2020/05/08/%E5%BC%80%E7%AF%87%EF%BC%81%E5%88%9D%E5%BF%83%E4%B8%8E%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>建立此博客的目的是为了记录一些平常学习中的所学所感。</p>
<h1 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h1><p>每天学习一点，若干天会推送一篇合集。</p>
<h1 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h1><p>现阶段双非一本计算机系，正往前端的路上使劲探索……</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何求解async await promise setTimeout的顺序？</title>
    <url>/2020/05/09/%E5%A6%82%E4%BD%95%E6%B1%82%E8%A7%A3async-await-promise-setTimeout%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端笔试题中常常有一种题，给定一定代码，让笔试者写这段代码的输出。一般这段代码，尝尝糅合了各种异步操作，比如async、await、promise、setTimeout，常常令人混淆。与此同时，由于node环境与浏览器环境执行这些异步操作的策略不同，也会有一些差异。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>重要概念：</strong></p>
<ul>
<li>首先我们要知道Javascript是<strong>单线程</strong>的</li>
<li>Javascript里的代码可以分为<strong>同步任务</strong>与<strong>异步任务</strong></li>
<li>同步任务会在<strong>主线程</strong>上执行。是在栈中执行，先进后出。</li>
<li>而异步任务会被放置到主线程之外的<strong>任务队列</strong>，先进先出</li>
<li>当主线程上的同步任务执行完成后，会读取任务队列的异步任务</li>
</ul>
<p><strong>宏任务与微任务</strong></p>
<p>上面讲到异步任务会在任务队列中执行。而执行异步代码的时候会分为两个队列，宏任务队列与微任务队列。</p>
<p>宏任务包括：</p>
<ul>
<li>一开始执行的整段的代码（script代码）</li>
<li>setTimeout、setInterval、postMessage等</li>
</ul>
<p>微任务包括：</p>
<ul>
<li><p>Promise.then后面的代码</p>
</li>
<li><p>await后面的代码（指的是 await func() 下一行开始的代码）</p>
</li>
<li><p>process.nextTick（node中的）</p>
<a id="more"></a>

</li>
</ul>
<h2 id="浏览器与Node中的事件轮询策略"><a href="#浏览器与Node中的事件轮询策略" class="headerlink" title="浏览器与Node中的事件轮询策略"></a>浏览器与Node中的事件轮询策略</h2><ul>
<li><p>对于<strong>浏览器</strong>来说，同步代码在栈中执行完毕后，会<strong>先去执行微任务队列</strong>，将微任务队列<strong>执行完</strong>后，<strong>再去执行宏任务队列</strong>。当每个宏任务被执行完后，准备执行下一个宏任务时，会检查这个执行完的宏任务是否产生了新的微任务。如果产生了新的微任务，则先去清空微任务队列，再执行下一个宏任务。依次轮循，直到清空整个异步队列。</p>
</li>
<li><p>对于<strong>Node</strong>来说。同样会现在栈中执行同步代码，不同的是Node有自己的多个处理不同问题的阶段和对应的队列，整个事件轮询机制是Libuv库实现的。与浏览器最大的不同是Node中有<strong>多个队列，分别执行不同操作</strong>。在每次<strong>队列切换</strong>时，都会区<strong>清空一次微任务队列</strong>。</p>
<p><img src="https://i.loli.net/2020/05/09/YwG4j9gW7T1fsev.png" alt="批注 2020-05-09 205449.png"></p>
</li>
</ul>
<p><strong>总结</strong>：Node会在队列切换时清空微任务队列，意思是这个队列可能会产生很多微任务，然而也要等这个队列执行完后再去清空这些微任务。然而浏览器会再产生微任务后，就去执行微任务，然后再执行下一个宏任务。</p>
<p><strong>举例</strong>：看如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout1"</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Promise1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout2"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>对于Node来说</p>
<p>1、将整段代码看作宏任务，解析时将两个setTimeout放入timers队列，而console.log(1)为同步任务，会输出1</p>
<p>2、此时检查微任务队列，发现微任务队列为空，切换到下一个队列</p>
<p>3、进入了timers队列，解析第一个setTimeout，发现有 console.log(“setTimeout1”)，输出setTimeout1。</p>
<p>4、发现有Promise.then，将里面的内容放入微任务队列</p>
<p><strong>5、解析第二个setTimeout队列，发现有console.log(“setTimeout2”);，输出setTimeout2</strong></p>
<p><strong>6、timers队列解析完毕，即将队列切换，检查微任务队列，发现有Promise.then，输出Promise1。</strong></p>
<p>对于浏览器来说</p>
<p>1、将整段代码看作宏任务，解析时将两个setTimeout放入宏任务队列，而console.log(1)为同步任务，会输出1</p>
<p>2、此时微任务队列为空，进入宏任务队列</p>
<p>3、解析第一个setTimeout，发现有发现有 console.log(“setTimeout1”)，输出setTimeout1。</p>
<p>4、发现有Promise.then，将里面的内容放入微任务队列</p>
<p><strong>5、因为产生了新的微任务，故执行完上一个宏任务后，立马清空微任务，输出Promise1</strong></p>
<p><strong>6、微任务执行完毕，继续执行第二个setTimeout，输出setTimeout2</strong></p>
<h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请写出输出内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"> </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">async1();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*浏览器中</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这段代码加了几乎所有”难点”难点</p>
<p><strong>注意：遇到 await 会跳出当前函数，并让出线程，再将await后面的代码放到 微任务（microtask）队列中</strong>。</p>
<p>执行过程为</p>
<p>1、同步执行, 输出“script start”。</p>
<p>2、遇到setTimeout，将里面代码放到宏任务队列。</p>
<p>3、继续往下，输出 “async1 start”，然后执行 async2函数，输出 “async2”。</p>
<p>4、async2执行完毕，<strong>将await async2 后面的代码（console.log(‘async1 end’);）加入到 微任务队列</strong></p>
<p>5、aysnc1()流程走完了，接下来进到Promise，同步输出’promise1’</p>
<p>6、遇到 <strong>promise.then，加入到微任务队列</strong></p>
<p>7、同步输出script end</p>
<p>8、当前宏任务执行完毕，查看微任务队列，按照先进先出原则</p>
<p>9、依次输出’async1 end’ “promise2”</p>
<p>10、执行下一个宏任务，里面只有一个setTimeout，所以最后输出setTimeout</p>
<p><strong>同步执行的：[script start] [async1 start] [async2] [promise1] [script end]</strong></p>
<p><strong>微任务队列：[async1 end] [ promise2 ]</strong></p>
<p><strong>宏任务队列：[setTimeout]</strong></p>
<blockquote>
<p>参考</p>
<p><a href="https://www.cnblogs.com/ly0612/p/setTimeout-promise-async-await-js-JavaScript.html" target="_blank" rel="noopener">https://www.cnblogs.com/ly0612/p/setTimeout-promise-async-await-js-JavaScript.html</a></p>
<p><a href="https://www.jianshu.com/p/c620ece29586" target="_blank" rel="noopener">https://www.jianshu.com/p/c620ece29586</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>纯JS瀑布流效果与动态加载</title>
    <url>/2020/05/09/%E7%80%91%E5%B8%83%E6%B5%81%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>瀑布流效果的特征是，里面的图片<strong>等宽不等高</strong>，并按列向下排列。同时，也可以拥有<strong>动态加载</strong>的功能。</p>
<p>可以参考<a href="https://www.mogu.com/" target="_blank" rel="noopener">蘑菇街</a>首页的效果</p>
<p>在社区中也有许多的瀑布流库可以使用，本文主要采用<strong>纯JS</strong>实现。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>主要是通过<strong>绝对布局</strong>的方法对每一个图片盒子进行定位，通过JS计算出每一张图片对应的<strong>left和top属性</strong></p>
<p>计算出每一个图片盒子的定位后，通过监听<strong>滚轮事件</strong>，<strong>判断</strong>是否要进行动态加载新的图片</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li><p><strong>首先搭建基本的html结构</strong></p>
<p>以下就是一个图片盒子的基本单元，我们复制40次这个单元以充满首屏。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/0.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p><strong>css中为图片限定尺寸并使用绝对定位</strong></p>
<p>去掉所有的padding和margin</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把body设置为relative，使得图片盒子的绝对定位是基于body的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后为每一个图片限定尺寸，高度设为auto是为了让图片自适应，不要忘记原则是<strong>图片等宽不等高</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">230px</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最重要的JS部分！</strong></p>
<ul>
<li><p>首先确定浏览器的显示区域内，一行能放多少个图片盒子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列数 = 页宽 / 每一个图片盒子的宽度，记得要进行取整</span></span><br><span class="line"> <span class="keyword">let</span> pageWidth = <span class="keyword">this</span>.document.body.clientWidth</span><br><span class="line"> <span class="keyword">let</span> boxWidth = <span class="number">230</span></span><br><span class="line"> <span class="keyword">let</span> colNum = <span class="built_in">Math</span>.floor(pageWidth / (boxWidth + <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>此时我们得到了在当前浏览器显示区域的大小内，我们能够显示<em>colNum</em>列</p>
</li>
<li><p>我们先排第一行元素，假设我们算出来当前的<em>colNum</em>为4</p>
<p>如下图所示，其中gap为两张图片之间的空隙：</p>
<p><img src="https://i.loli.net/2020/05/09/rgqvVwUpJISHMZO.png" alt="图片1.png"></p>
</li>
</ul>
</li>
</ul>
<pre><code>我们可以轻易的得出 第一行的图片top都为0

第一张图片的 left = （boxWidth  +  gap）*0

第二张图片的 left = （boxWidth  +  gap）*1

第三张图片的 left = （boxWidth  +  gap）*2

第四张图片的 left = （boxWidth  +  gap）*3

我们获取所有的box形成boxs数组，因此我们可以对第一行进行排列：

其中的*colHeigth*是一个数组，维护每一列的高度。每一列的高度=这一列所有图片的总和加上间隙。

这个*colHeight*数组是后续图片排序的重要依据！

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxs.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 先排列第一行</span></span><br><span class="line">          <span class="keyword">if</span> (i &lt; colNum) &#123;</span><br><span class="line">              boxs[i].style.cssText = <span class="string">`left:<span class="subst">$&#123;i * (boxWidth + gap)&#125;</span>px`</span></span><br><span class="line">              colHeight.push(boxs[i].clientHeight)</span><br><span class="line">        &#125;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>当我们需要排列第五张图片时</p>
<p>第五张图片需要放在哪呢？放在<strong>当前高度最小的所在列的下面</strong></p>
<p>如下图，在第一行排完后，第三张图片所在列的高度最小，故第五张图片就排在第三列的下面！</p>
<p><img src="https://i.loli.net/2020/05/09/VNxpL4k5Ss89T1v.png" alt="图片2.png"></p>
<p>故第五张图片的top = 第三张图片的高度 + 间隙； left = 第三张图片的left值</p>
<p>排完后，我们要更新<em>colHeight</em>对应列的高度，也就是把原先第三列的高度加上第五张图片的高度和gap。</p>
<p>第五张、第六张……都可以这么做。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxs.length; i++) &#123;</span><br><span class="line">       <span class="comment">// 先排列第一行</span></span><br><span class="line">       <span class="keyword">if</span> (i &lt; colNum) &#123;</span><br><span class="line">          boxs[i].style.cssText = <span class="string">`left:<span class="subst">$&#123;i * (boxWidth + gap)&#125;</span>px`</span></span><br><span class="line">          colHeight.push(boxs[i].clientHeight)</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 从第二行开始，找当前高度最短的列</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> minHeight = <span class="built_in">Math</span>.min(...colHeight)</span><br><span class="line">          <span class="keyword">let</span> minIndex = colHeight.indexOf(minHeight)</span><br><span class="line">          boxs[i].style.cssText = <span class="string">`top:<span class="subst">$&#123;minHeight + 		                                     gap&#125;</span>px;left:<span class="subst">$&#123;boxs[minIndex].offsetLeft&#125;</span>px`</span></span><br><span class="line">          colHeight[minIndex] += (boxs[i].clientHeight + gap)</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>至此，已经完成了瀑布流的基本布局。</p>
<p>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boxs = <span class="keyword">this</span>.document.getElementsByClassName(<span class="string">'box'</span>)</span><br><span class="line"><span class="keyword">let</span> waterfall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 确定浏览器显示区域内，一行能放多少列图片盒子</span></span><br><span class="line">    <span class="keyword">let</span> pageWidth = <span class="keyword">this</span>.document.body.clientWidth</span><br><span class="line">    <span class="keyword">let</span> boxWidth = <span class="number">230</span></span><br><span class="line">    <span class="keyword">let</span> gap = <span class="number">7</span></span><br><span class="line">    <span class="keyword">let</span> colNum = <span class="built_in">Math</span>.floor(pageWidth / (boxWidth + <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">let</span> colHeight = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxs.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 先排列第一行</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; colNum) &#123;</span><br><span class="line">            boxs[i].style.cssText = <span class="string">`left:<span class="subst">$&#123;i * (boxWidth + gap)&#125;</span>px`</span></span><br><span class="line">            colHeight.push(boxs[i].clientHeight)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第二行开始，找当前高度最短的列</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> minHeight = <span class="built_in">Math</span>.min(...colHeight)</span><br><span class="line">            <span class="keyword">let</span> minIndex = colHeight.indexOf(minHeight)</span><br><span class="line">            boxs[i].style.cssText = <span class="string">`top:<span class="subst">$&#123;minHeight + gap&#125;</span>px;left:<span class="subst">$&#123;boxs[minIndex].offsetLeft&#125;</span>px`</span></span><br><span class="line">            colHeight[minIndex] += (boxs[i].clientHeight + gap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><ul>
<li><p>实现改变窗口大小时，布局变化（列数）</p>
<p>很简单，只要监听resize事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听resize事件</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    waterfall()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现动态加载</p>
<p>原理如下图，绿色图片盒子是当前boxs数组中的最后一个元素，当用户滚动滚动条，绿色元素显示出来，我们就需要加载新的图片了。</p>
<p>其中offsetTop、clientHeight是不会变化的，只有scrollTop会随着滚动条的滚动而增加。故临界条件是</p>
<p><strong>offsetTop &lt;  ScrollTop + clientHeight</strong> 时，就要加载新的图片</p>
<p><img src="https://i.loli.net/2020/05/09/Db9REgoVziN7tu8.png" alt="图片3.png"></p>
</li>
</ul>
<p>​    这里使用一个数组来模拟新的图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">    	...</span><br><span class="line">    ]</span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (boxs[boxs.length - <span class="number">1</span>].offsetTop + <span class="built_in">Math</span>.floor(boxs[boxs.length - <span class="number">1</span>].clientHeight / <span class="number">2</span>) &lt; <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 创建图片盒子单元</span></span><br><span class="line">                <span class="keyword">let</span> div = <span class="keyword">this</span>.document.createElement(<span class="string">'div'</span>)</span><br><span class="line">                div.className = <span class="string">'box'</span></span><br><span class="line">                <span class="keyword">let</span> img = <span class="keyword">this</span>.document.createElement(<span class="string">'img'</span>)</span><br><span class="line">                img.src = data[i]</span><br><span class="line">                div.appendChild(img)</span><br><span class="line">                body = <span class="keyword">this</span>.document.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span><br><span class="line">                body.appendChild(div)</span><br><span class="line">                <span class="comment">// 追加到boxs数组中</span></span><br><span class="line">                boxs = <span class="keyword">this</span>.document.getElementsByClassName(<span class="string">'box'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            waterfall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    至此，完成了动态加载，下拉即可触发</p>
<p><img src="https://i.loli.net/2020/05/09/4v5P76aiXuL3hnM.png" alt="批注 2020-05-09 103755.png"></p>
]]></content>
      <tags>
        <tag>瀑布流 JS</tag>
      </tags>
  </entry>
</search>
