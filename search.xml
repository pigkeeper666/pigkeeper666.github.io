<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>认清Token的职责</title>
    <url>/2020/05/11/%E8%AE%A4%E6%B8%85Token%E7%9A%84%E8%81%8C%E8%B4%A3/</url>
    <content><![CDATA[<h2 id="Session-Cookie"><a href="#Session-Cookie" class="headerlink" title="Session+Cookie"></a>Session+Cookie</h2><p>我们知道，http是无状态的，但是在应用中我们常常需要保留用户的登陆状态，也就是保持会话。</p>
<p>一般我们采取的方案是cookie+session这一套，具体过程不再赘述，总结几点：</p>
<p><strong>1、cookie的作用域是domain本身以及domain下的所有子域名。也就是说客户端代码和服务器代码运行在同一台服务器上比较好使用，因为cookie是不能跨域名的！！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;test1.demo.com:8080 与 http:&#x2F;&#x2F;test2.demo.com:8081 之间共享 cookie</span><br></pre></td></tr></table></figure>

<p>注意：test1.demo.com 是 demo.com的子域名</p>
<p><strong>2、服务器端session存在哪？内存还是数据库？当存在内存中时，服务器采用了多台机器负载均衡，怎么办？可以共享内存吗？其次万一服务器这边重启了session会消失吧！当存在数据库中，那么当用户量大的时候，数据库的负担会遍大，同时也需要频繁的读写。</strong></p>
<p><strong>3、可能会遭到CSRF攻击（cookie劫持）</strong></p>
<p>针对上面三个问题，我们可以想想如何解决：</p>
<p>1、用token，可以跨域名。</p>
<p>2、能不能不把session存在服务端，而存在客户端呢？</p>
<p>3、不使用cookie了，不就能避免CSRF了嘛？</p>
<a id="more"></a>

<h2 id="什么是Token"><a href="#什么是Token" class="headerlink" title="什么是Token"></a>什么是Token</h2><p><strong>Token</strong>是服务端生成的一串字符串，以作客户端进行请求的一个<strong>令牌</strong>，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<p>优点：</p>
<p><strong>1、可以跨域名</strong></p>
<p><strong>2、服务端压力小，不用频繁的操作数据库，只要对token进行签名与“解密”</strong></p>
<p><strong>3、规避了CSRF攻击。</strong></p>
<p>以下讨论无状态Token</p>
<blockquote>
<p>注意，所谓无状态Token就是服务端不存储Token，而让客户端存储。</p>
</blockquote>
<p>你可能想问，如果服务端不存，那怎么验证Token呢？</p>
<blockquote>
<p>假设我用这个数据<code>{id:12345}</code>生成一个<code>token</code>,这个<code>token</code>分为三段信息：</p>
<p>第一段是头部<code>Header</code>，包括的信息有签名使用的算法（HS256等）、令牌的类型等。</p>
<p>第二部分就是我们的数据<code>Payload</code>通过<code>base64</code>加密。包括发行人、到期时间、发布时间以及自定义字段等数据。</p>
<p>第三部分是加密的签名。通过<code>Header</code>和<code>Payload</code>以及我们的服务端的私钥生成。签名是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</p>
</blockquote>
<p>因此，当服务端发回Token时，<strong>服务端再次对第一二部分进行数字签名，与第三部分对比</strong>。由于服务器私钥我们认为他是安全的，别人无法获得，因此当这两个值是一样的，则我们可以认为<strong>用户的登录信息没有被篡改。</strong>因此完成了Token的验证。</p>
<p>综上，Token的作用是<strong>验证身份</strong>，<strong>安全问题不在它本身的职责范围内</strong></p>
<h2 id="非常容易搞混的点"><a href="#非常容易搞混的点" class="headerlink" title="非常容易搞混的点"></a>非常容易搞混的点</h2><p>这个点便是<strong>安全问题。</strong></p>
<p>你可能会想，倘若我发起<strong>中间人攻击</strong>：我截取了服务端返回的Token值，那么我便可以伪造真实的用户做一些坏事。</p>
<p>没错，的确会这样，然而这不是Token的问题，你想，就算用cookie+session难道不会遇到这种问题嘛？</p>
<p>那怎么办？</p>
<p>事实上，这是<strong>HTTPS中的SSL/TSL防止的事情</strong>：通过对计算机中的网络流量进行加密（密钥协商是通过SSL握手协商而得），就算截取到了这个密文也无法进行破解，除非它们能够以某种方式获取服务器的私有SSL密钥的副本（不太可能）。</p>
<p>同样还有一些别的安全防范手段：</p>
<p>比如就不想别人知道<code>token</code>里面的数据，那就可以在给这个数据加一下密。或者担心这个<code>token</code>会被别人获取，照成这个用户的损失,那就需要在加别的手段来保证，比如通过验证来访的 ip ，比如设置更短的过期时间，比如你用的<code>HTTPS</code>，或者添加更多的验证等等。通过增加第三方的窃取成本，来降低被窃取的几率！</p>
<p>这便是风控手段。</p>
<p>用一个形象的例子来解释：</p>
<blockquote>
<p>你可以把<code>token</code>想象为银行的验钞机,验钞机的职责是验证假钞保证收进来的钱都是真钱，至于这个钱是偷的抢的,还是正常交易，那就不是验钞机管的了，那是警察叔叔管的。</p>
</blockquote>
<h2 id="扯床单"><a href="#扯床单" class="headerlink" title="扯床单"></a>扯床单</h2><p>什么叫扯床单？就是当你铺床时，左边的床单没平，于是你用力一拉…左边的床单是平了，然而右边又乱了……</p>
<p><strong>Token规避了CSRF攻击，然而却增加了XSS攻击的风险</strong></p>
<p>Token一般我们存在哪里？对！客户端。那客户端的哪里？</p>
<p>存在cookie里吗？那本质上是不是又和cookie+session一样了？会造成token版的“CSRF”攻击吧。</p>
<p>一般我们存在<strong>WebStorage</strong>里，比如<strong>LocalStorage、SessionStorage</strong>里。</p>
<p>这两个值是不会像cookie一样被自动携带访问某些网站的。</p>
<p><strong>然而</strong>，这两个值是可以被JavaScript访问的，也就是说，仍然会有XSS攻击的风险！</p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇！初心与目标</title>
    <url>/2020/05/08/%E5%BC%80%E7%AF%87%EF%BC%81%E5%88%9D%E5%BF%83%E4%B8%8E%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>建立此博客的目的是为了记录一些平常学习中的所学所感。</p>
<h1 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h1><p>每天学习一点，若干天会推送一篇合集。</p>
<h1 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h1><p>现阶段双非一本计算机系，正往前端的路上使劲探索……</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何求解async await promise setTimeout的顺序？</title>
    <url>/2020/05/09/%E5%A6%82%E4%BD%95%E6%B1%82%E8%A7%A3async-await-promise-setTimeout%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端笔试题中常常有一种题，给定一定代码，让笔试者写这段代码的输出。一般这段代码，尝尝糅合了各种异步操作，比如async、await、promise、setTimeout，常常令人混淆。与此同时，由于node环境与浏览器环境执行这些异步操作的策略不同，也会有一些差异。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>重要概念：</strong></p>
<ul>
<li>首先我们要知道Javascript是<strong>单线程</strong>的</li>
<li>Javascript里的代码可以分为<strong>同步任务</strong>与<strong>异步任务</strong></li>
<li>同步任务会在<strong>主线程</strong>上执行。是在栈中执行，先进后出。</li>
<li>而异步任务会被放置到主线程之外的<strong>任务队列</strong>，先进先出</li>
<li>当主线程上的同步任务执行完成后，会读取任务队列的异步任务</li>
</ul>
<p><strong>宏任务与微任务</strong></p>
<p>上面讲到异步任务会在任务队列中执行。而执行异步代码的时候会分为两个队列，宏任务队列与微任务队列。</p>
<p>宏任务包括：</p>
<ul>
<li>一开始执行的整段的代码（script代码）</li>
<li>setTimeout、setInterval、postMessage等</li>
</ul>
<p>微任务包括：</p>
<ul>
<li><p>Promise.then后面的代码</p>
</li>
<li><p>await后面的代码（指的是 await func() 下一行开始的代码）</p>
</li>
<li><p>process.nextTick（node中的）</p>
<a id="more"></a>

</li>
</ul>
<h2 id="浏览器与Node中的事件轮询策略"><a href="#浏览器与Node中的事件轮询策略" class="headerlink" title="浏览器与Node中的事件轮询策略"></a>浏览器与Node中的事件轮询策略</h2><ul>
<li><p>对于<strong>浏览器</strong>来说，同步代码在栈中执行完毕后，会<strong>先去执行微任务队列</strong>，将微任务队列<strong>执行完</strong>后，<strong>再去执行宏任务队列</strong>。当每个宏任务被执行完后，准备执行下一个宏任务时，会检查这个执行完的宏任务是否产生了新的微任务。如果产生了新的微任务，则先去清空微任务队列，再执行下一个宏任务。依次轮循，直到清空整个异步队列。</p>
</li>
<li><p>对于<strong>Node</strong>来说。同样会现在栈中执行同步代码，不同的是Node有自己的多个处理不同问题的阶段和对应的队列，整个事件轮询机制是Libuv库实现的。与浏览器最大的不同是Node中有<strong>多个队列，分别执行不同操作</strong>。在每次<strong>队列切换</strong>时，都会区<strong>清空一次微任务队列</strong>。</p>
<p><img src="https://i.loli.net/2020/05/09/YwG4j9gW7T1fsev.png" alt="批注 2020-05-09 205449.png"></p>
</li>
</ul>
<p><strong>总结</strong>：Node会在队列切换时清空微任务队列，意思是这个队列可能会产生很多微任务，然而也要等这个队列执行完后再去清空这些微任务。然而浏览器会再产生微任务后，就去执行微任务，然后再执行下一个宏任务。</p>
<p><strong>举例</strong>：看如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout1"</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Promise1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout2"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>对于Node来说</p>
<p>1、将整段代码看作宏任务，解析时将两个setTimeout放入timers队列，而console.log(1)为同步任务，会输出1</p>
<p>2、此时检查微任务队列，发现微任务队列为空，切换到下一个队列</p>
<p>3、进入了timers队列，解析第一个setTimeout，发现有 console.log(“setTimeout1”)，输出setTimeout1。</p>
<p>4、发现有Promise.then，将里面的内容放入微任务队列</p>
<p><strong>5、解析第二个setTimeout队列，发现有console.log(“setTimeout2”);，输出setTimeout2</strong></p>
<p><strong>6、timers队列解析完毕，即将队列切换，检查微任务队列，发现有Promise.then，输出Promise1。</strong></p>
<p>对于浏览器来说</p>
<p>1、将整段代码看作宏任务，解析时将两个setTimeout放入宏任务队列，而console.log(1)为同步任务，会输出1</p>
<p>2、此时微任务队列为空，进入宏任务队列</p>
<p>3、解析第一个setTimeout，发现有发现有 console.log(“setTimeout1”)，输出setTimeout1。</p>
<p>4、发现有Promise.then，将里面的内容放入微任务队列</p>
<p><strong>5、因为产生了新的微任务，故执行完上一个宏任务后，立马清空微任务，输出Promise1</strong></p>
<p><strong>6、微任务执行完毕，继续执行第二个setTimeout，输出setTimeout2</strong></p>
<h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请写出输出内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"> </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">async1();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*浏览器中</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这段代码加了几乎所有”难点”难点</p>
<p><strong>注意：遇到 await 会跳出当前函数，并让出线程，再将await后面的代码放到 微任务（microtask）队列中</strong>。</p>
<p>执行过程为</p>
<p>1、同步执行, 输出“script start”。</p>
<p>2、遇到setTimeout，将里面代码放到宏任务队列。</p>
<p>3、继续往下，输出 “async1 start”，然后执行 async2函数，输出 “async2”。</p>
<p>4、async2执行完毕，<strong>将await async2 后面的代码（console.log(‘async1 end’);）加入到 微任务队列</strong></p>
<p>5、aysnc1()流程走完了，接下来进到Promise，同步输出’promise1’</p>
<p>6、遇到 <strong>promise.then，加入到微任务队列</strong></p>
<p>7、同步输出script end</p>
<p>8、当前宏任务执行完毕，查看微任务队列，按照先进先出原则</p>
<p>9、依次输出’async1 end’ “promise2”</p>
<p>10、执行下一个宏任务，里面只有一个setTimeout，所以最后输出setTimeout</p>
<p><strong>同步执行的：[script start] [async1 start] [async2] [promise1] [script end]</strong></p>
<p><strong>微任务队列：[async1 end] [ promise2 ]</strong></p>
<p><strong>宏任务队列：[setTimeout]</strong></p>
<blockquote>
<p>参考</p>
<p><a href="https://www.cnblogs.com/ly0612/p/setTimeout-promise-async-await-js-JavaScript.html" target="_blank" rel="noopener">https://www.cnblogs.com/ly0612/p/setTimeout-promise-async-await-js-JavaScript.html</a></p>
<p><a href="https://www.jianshu.com/p/c620ece29586" target="_blank" rel="noopener">https://www.jianshu.com/p/c620ece29586</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>图片懒加载与防抖节流</title>
    <url>/2020/05/10/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>图片懒加载是一种比较常见的优化方式，其效果是当用户拉动滚动条到图片位置时，图片才开始加载（未加载之前会用一张默认图片代替），这样可以有效地防止所有图片集中请求加载，造成拥堵。</p>
<p>下图是建议的效果，当拉动滚动条到当前加载的图片的最后一张时，会发现下一张还未加载。</p>
<p>然而继续往下拉动后，这张图片会进行加载</p>
<p><img src="https://wx2.sbimg.cn/2020/05/10/MDTCPC1OMCGBM_WHPX.png" alt="MDTCPC1OMCGBM_WHPX.png"></p>
<a id="more"></a>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>其实主要的思想与我之前的文章<a href="https://www.pigkeeper.xyz/2020/05/09/瀑布流效果/" target="_blank" rel="noopener">纯JS瀑布流效果与动态加载</a>里的动态加载非常的相似，都是计算一个滚动的阈值，达到这个阈值后便进行图片的加载。</p>
<p><strong>首先我们搭建简单的html结构</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，img的src属性都是”./default.png”，这是一张默认图，也就是上图的蓝色图片，而图片真正的src存在data-src中。data-src是一个自定义的数据，当我们获取到某个img的dom节点对象时，我们可以通过一些语句来获得data-src的值，方法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(img.dataset.src)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会输出data-src的内容</span></span><br></pre></td></tr></table></figure>

<p><strong>其次是css</strong></p>
<p>这里只是限定图片的大小，并居中显示</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        <span class="selector-tag">img</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">230px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">320px</span>;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.box</span> &#123;</span><br><span class="line">            <span class="attribute">display</span>: flex;</span><br><span class="line">            <span class="attribute">flex-direction</span>: column;</span><br><span class="line">            <span class="attribute">align-items</span>: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>js部分</strong></p>
<p>至此，我们很容易的想到，如果要实现图片的懒加载，我们只需要监听滚动事件，当触发某个条件时，我们就把img标签的src属性值替换为data-src的值，这样就能加载图片了。</p>
<p>那么，这个条件是什么呢？</p>
<p>同样用一张图来说明：</p>
<p><img src="https://wx2.sbimg.cn/2020/05/10/1.png" alt="1.png"></p>
<p>其中offsetTop、halfHeight、clientHeight都不会变，只有scrollTop会变</p>
<p>故当<strong>offsetTop + halfHeight &lt; scrollTop + clientHeight</strong>时，加载图片。</p>
<p><strong>以下是完整代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有的img节点</span></span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span><br><span class="line">    <span class="comment">// 将伪数组转化为数组</span></span><br><span class="line">    img = [...img]</span><br><span class="line">    img.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 图片高度的一半</span></span><br><span class="line">        <span class="keyword">let</span> halfHeight = <span class="built_in">Math</span>.floor(element.clientHeight / <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (element.offsetTop + halfHeight &lt; <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">            <span class="comment">// 替换src</span></span><br><span class="line">            element.src = element.dataset.src</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>至此，基本完成了图片的懒加载。</p>
<h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><blockquote>
<p> 在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p>
<p>一般可以用防抖和节流来解决这个问题。</p>
</blockquote>
<p><strong>防抖（debounce）</strong></p>
<p><strong>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间，用定时器实现。</strong></p>
<p>下面是具体的实现，注意看我的注释。闭包是为了保留timer这个状态，而apply的作用在注释中有写到，可以仔细去品味一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 闭包</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// !!!!很重要</span></span><br><span class="line">    <span class="comment">// 这个函数是事件对象调用的函数，事件会给这个函数一个参数e 下面可以用arguments拿到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            clearInterval(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 由于是箭头函数，这个this和arguments是从上面继承下来的</span></span><br><span class="line">            <span class="comment">// 用apply是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。</span></span><br><span class="line">            <span class="comment">// 这个arguments就是 e</span></span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>节流（throttle）</strong></p>
<p><strong>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。</strong></p>
<p>懂了防抖，节流也会相对容易理解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">return</span></span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载的优化"><a href="#图片懒加载的优化" class="headerlink" title="图片懒加载的优化"></a>图片懒加载的优化</h2><p>上面我们实现的懒加载，是依靠监听滚动条。当我们滚动时，会频繁的触发计算，是否可以优化，让它少触发几次？那我们是应该用防抖还是节流呢？</p>
<p>想一下，如果用防抖，会导致一直触发事件，一直重置定时器，是不是有可能一直加载不出图片？</p>
<p>而用节流，无论你在这段时间里触发多少次，过了这段时间我一定会执行一次，这是不是就满足了我们的需求！</p>
<p>注意书写形式</p>
<p><strong>完整代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动条用节流比较好</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span><br><span class="line">    <span class="comment">// console.log(img)</span></span><br><span class="line">    img = [...img]</span><br><span class="line">    img.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> halfHeight = <span class="built_in">Math</span>.floor(element.clientHeight / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (element.offsetTop + halfHeight &lt; <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">            element.src = element.dataset.src</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/c8b86b09daf0" target="_blank" rel="noopener">https://www.jianshu.com/p/c8b86b09daf0</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>图片懒加载 节流 防抖</tag>
      </tags>
  </entry>
  <entry>
    <title>纯JS瀑布流效果与动态加载</title>
    <url>/2020/05/09/%E7%80%91%E5%B8%83%E6%B5%81%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>瀑布流效果的特征是，里面的图片<strong>等宽不等高</strong>，并按列向下排列。同时，也可以拥有<strong>动态加载</strong>的功能。</p>
<p>可以参考<a href="https://www.mogu.com/" target="_blank" rel="noopener">蘑菇街</a>首页的效果</p>
<p>在社区中也有许多的瀑布流库可以使用，本文主要采用<strong>纯JS</strong>实现。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>主要是通过<strong>绝对布局</strong>的方法对每一个图片盒子进行定位，通过JS计算出每一张图片对应的<strong>left和top属性</strong></p>
<p>计算出每一个图片盒子的定位后，通过监听<strong>滚轮事件</strong>，<strong>判断</strong>是否要进行动态加载新的图片</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li><p><strong>首先搭建基本的html结构</strong></p>
<p>以下就是一个图片盒子的基本单元，我们复制40次这个单元以充满首屏。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/0.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p><strong>css中为图片限定尺寸并使用绝对定位</strong></p>
<p>去掉所有的padding和margin</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把body设置为relative，使得图片盒子的绝对定位是基于body的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后为每一个图片限定尺寸，高度设为auto是为了让图片自适应，不要忘记原则是<strong>图片等宽不等高</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">230px</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最重要的JS部分！</strong></p>
<ul>
<li><p>首先确定浏览器的显示区域内，一行能放多少个图片盒子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列数 = 页宽 / 每一个图片盒子的宽度，记得要进行取整</span></span><br><span class="line"> <span class="keyword">let</span> pageWidth = <span class="keyword">this</span>.document.body.clientWidth</span><br><span class="line"> <span class="keyword">let</span> boxWidth = <span class="number">230</span></span><br><span class="line"> <span class="keyword">let</span> colNum = <span class="built_in">Math</span>.floor(pageWidth / (boxWidth + <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>此时我们得到了在当前浏览器显示区域的大小内，我们能够显示<em>colNum</em>列</p>
</li>
<li><p>我们先排第一行元素，假设我们算出来当前的<em>colNum</em>为4</p>
<p>如下图所示，其中gap为两张图片之间的空隙：</p>
<p><img src="https://i.loli.net/2020/05/09/rgqvVwUpJISHMZO.png" alt="图片1.png"></p>
</li>
</ul>
</li>
</ul>
<pre><code>我们可以轻易的得出 第一行的图片top都为0

第一张图片的 left = （boxWidth  +  gap）*0

第二张图片的 left = （boxWidth  +  gap）*1

第三张图片的 left = （boxWidth  +  gap）*2

第四张图片的 left = （boxWidth  +  gap）*3

我们获取所有的box形成boxs数组，因此我们可以对第一行进行排列：

其中的*colHeigth*是一个数组，维护每一列的高度。每一列的高度=这一列所有图片的总和加上间隙。

这个*colHeight*数组是后续图片排序的重要依据！

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxs.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 先排列第一行</span></span><br><span class="line">          <span class="keyword">if</span> (i &lt; colNum) &#123;</span><br><span class="line">              boxs[i].style.cssText = <span class="string">`left:<span class="subst">$&#123;i * (boxWidth + gap)&#125;</span>px`</span></span><br><span class="line">              colHeight.push(boxs[i].clientHeight)</span><br><span class="line">        &#125;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>当我们需要排列第五张图片时</p>
<p>第五张图片需要放在哪呢？放在<strong>当前高度最小的所在列的下面</strong></p>
<p>如下图，在第一行排完后，第三张图片所在列的高度最小，故第五张图片就排在第三列的下面！</p>
<p><img src="https://i.loli.net/2020/05/09/VNxpL4k5Ss89T1v.png" alt="图片2.png"></p>
<p>故第五张图片的top = 第三张图片的高度 + 间隙； left = 第三张图片的left值</p>
<p>排完后，我们要更新<em>colHeight</em>对应列的高度，也就是把原先第三列的高度加上第五张图片的高度和gap。</p>
<p>第五张、第六张……都可以这么做。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxs.length; i++) &#123;</span><br><span class="line">       <span class="comment">// 先排列第一行</span></span><br><span class="line">       <span class="keyword">if</span> (i &lt; colNum) &#123;</span><br><span class="line">          boxs[i].style.cssText = <span class="string">`left:<span class="subst">$&#123;i * (boxWidth + gap)&#125;</span>px`</span></span><br><span class="line">          colHeight.push(boxs[i].clientHeight)</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 从第二行开始，找当前高度最短的列</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> minHeight = <span class="built_in">Math</span>.min(...colHeight)</span><br><span class="line">          <span class="keyword">let</span> minIndex = colHeight.indexOf(minHeight)</span><br><span class="line">          boxs[i].style.cssText = <span class="string">`top:<span class="subst">$&#123;minHeight + 		                                     gap&#125;</span>px;left:<span class="subst">$&#123;boxs[minIndex].offsetLeft&#125;</span>px`</span></span><br><span class="line">          colHeight[minIndex] += (boxs[i].clientHeight + gap)</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>至此，已经完成了瀑布流的基本布局。</p>
<p>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boxs = <span class="keyword">this</span>.document.getElementsByClassName(<span class="string">'box'</span>)</span><br><span class="line"><span class="keyword">let</span> waterfall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 确定浏览器显示区域内，一行能放多少列图片盒子</span></span><br><span class="line">    <span class="keyword">let</span> pageWidth = <span class="keyword">this</span>.document.body.clientWidth</span><br><span class="line">    <span class="keyword">let</span> boxWidth = <span class="number">230</span></span><br><span class="line">    <span class="keyword">let</span> gap = <span class="number">7</span></span><br><span class="line">    <span class="keyword">let</span> colNum = <span class="built_in">Math</span>.floor(pageWidth / (boxWidth + <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">let</span> colHeight = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxs.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 先排列第一行</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; colNum) &#123;</span><br><span class="line">            boxs[i].style.cssText = <span class="string">`left:<span class="subst">$&#123;i * (boxWidth + gap)&#125;</span>px`</span></span><br><span class="line">            colHeight.push(boxs[i].clientHeight)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第二行开始，找当前高度最短的列</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> minHeight = <span class="built_in">Math</span>.min(...colHeight)</span><br><span class="line">            <span class="keyword">let</span> minIndex = colHeight.indexOf(minHeight)</span><br><span class="line">            boxs[i].style.cssText = <span class="string">`top:<span class="subst">$&#123;minHeight + gap&#125;</span>px;left:<span class="subst">$&#123;boxs[minIndex].offsetLeft&#125;</span>px`</span></span><br><span class="line">            colHeight[minIndex] += (boxs[i].clientHeight + gap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><ul>
<li><p>实现改变窗口大小时，布局变化（列数）</p>
<p>很简单，只要监听resize事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听resize事件</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    waterfall()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现动态加载</p>
<p>原理如下图，绿色图片盒子是当前boxs数组中的最后一个元素，当用户滚动滚动条，绿色元素显示出来，我们就需要加载新的图片了。</p>
<p>其中offsetTop、clientHeight是不会变化的，只有scrollTop会随着滚动条的滚动而增加。故临界条件是</p>
<p><strong>offsetTop &lt;  ScrollTop + clientHeight</strong> 时，就要加载新的图片</p>
<p><img src="https://i.loli.net/2020/05/09/Db9REgoVziN7tu8.png" alt="图片3.png"></p>
</li>
</ul>
<p>​    这里使用一个数组来模拟新的图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">    	...</span><br><span class="line">    ]</span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (boxs[boxs.length - <span class="number">1</span>].offsetTop + <span class="built_in">Math</span>.floor(boxs[boxs.length - <span class="number">1</span>].clientHeight / <span class="number">2</span>) &lt; <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 创建图片盒子单元</span></span><br><span class="line">                <span class="keyword">let</span> div = <span class="keyword">this</span>.document.createElement(<span class="string">'div'</span>)</span><br><span class="line">                div.className = <span class="string">'box'</span></span><br><span class="line">                <span class="keyword">let</span> img = <span class="keyword">this</span>.document.createElement(<span class="string">'img'</span>)</span><br><span class="line">                img.src = data[i]</span><br><span class="line">                div.appendChild(img)</span><br><span class="line">                body = <span class="keyword">this</span>.document.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span><br><span class="line">                body.appendChild(div)</span><br><span class="line">                <span class="comment">// 追加到boxs数组中</span></span><br><span class="line">                boxs = <span class="keyword">this</span>.document.getElementsByClassName(<span class="string">'box'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            waterfall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    至此，完成了动态加载，下拉即可触发</p>
<p><img src="https://i.loli.net/2020/05/09/4v5P76aiXuL3hnM.png" alt="批注 2020-05-09 103755.png"></p>
]]></content>
      <tags>
        <tag>瀑布流 JS</tag>
      </tags>
  </entry>
</search>
