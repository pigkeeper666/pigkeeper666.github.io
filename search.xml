<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JS的隐式类型转换</title>
    <url>/2020/05/17/JS%E7%9A%84%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Vue.nextTick</title>
    <url>/2020/05/12/Vue-nextTick/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote>
<p>本文主要参考了博客<a href="https://segmentfault.com/a/1190000012861862" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012861862</a></p>
<p>并解决了自己在使用vue中遇到的问题</p>
</blockquote>
<h2 id="定义与疑问"><a href="#定义与疑问" class="headerlink" title="定义与疑问"></a>定义与疑问</h2><blockquote>
<p>Vue.nextTick()的定义如下：</p>
<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
</blockquote>
<p>我们不禁带着以下疑问：</p>
<p>1、DOM更新循环是什么？</p>
<p>2、下次更新循环是什么时候？</p>
<p>3、什么时候会用到？（也就是为什么我们要延迟回调）</p>
<a id="more"></a>

<h2 id="Vue异步更新DOM"><a href="#Vue异步更新DOM" class="headerlink" title="Vue异步更新DOM"></a>Vue异步更新DOM</h2><p>以下摘自Vue官方文档：</p>
<blockquote>
<p>可能你还没有注意到，Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。</p>
<p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。</p>
</blockquote>
<p>以上文案说明：<strong>Vue不是数据发生变化后DOM立即变化，而是通过一定的策略进行DOM更新。即异步更新</strong></p>
<p>具体来说，异步执行的运行机制如下。</p>
<blockquote>
<p>（1）所有<strong>同步任务</strong>都在主线程上执行，形成一个执行栈（execution context stack）。<br>（2）主线程之外，还存在一个<strong>“任务队列”（task queue）</strong>。只要<strong>异步任务有了运行结果</strong>，就在”任务队列”之中<strong>放置</strong>一个事件。<br>（3）一旦”执行栈”中的所有<strong>同步任务执行完毕</strong>，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>（4）主线程不断<strong>重复</strong>上面的第三步。</p>
</blockquote>
<p><a href="https://sbimg.cn/image/mlBy1" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/05/12/3835190331-580cd2a9443a7_articlex.md.png" alt="3835190331-580cd2a9443a7_articlex.md.png"></a></p>
<h2 id="事件循环说明"><a href="#事件循环说明" class="headerlink" title="事件循环说明"></a>事件循环说明</h2><p>Vue在修改数据后，视图不会立即更新，而是等同一事件循环中所有数据变化完成后，再统一进行视图更新。</p>
<p>举例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改变数据</span></span><br><span class="line">vm.message = <span class="string">'changed'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新</span></span><br><span class="line"><span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">// 并不会得到'changed'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样可以，nextTick里面的代码会在DOM更新后执行</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(vm.$el.textContent) <span class="comment">//可以得到'changed'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>你的本意是想要使用已经更新完的DOM。如果不用nextTick，你在修改完值以后DOM还没有进行更新呢！</p>
<p>图解如下：</p>
<p><a href="https://sbimg.cn/image/mlgbJ" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/05/12/1596618069-5a5da8c8522c2_articlex.png" alt="1596618069-5a5da8c8522c2_articlex.png"></a></p>
<p>此时的事件循环过程如下：</p>
<ul>
<li>第一个tick（上图的第一个黑方块，即本次更新循环）<ul>
<li>首先修改数据，这是同步的任务。同一事件循环的所有同步任务都在主线程上执行，形成一个执行栈，此时仍未涉及DOM</li>
<li>侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次的触发，只会被推入到队列中一次。</li>
</ul>
</li>
<li>第二个tick（上图的第二个黑方块，即’下次更新循环’）<ul>
<li>同步任务执行完毕，开始执行异步watcher队列的任务，更新DOM。Vue在内部尝试对异步队列使用原生的<code>Promise.then()</code>和<code>MessageChannel</code>方法，如果环境不支持，会使用<code>setTimeout(fn,0)</code>代替。</li>
</ul>
</li>
<li>第三个tick（最后一个方块）<ul>
<li>此时便是‘下次DOM更新循环结束后’</li>
<li>此时可以通过<code>Vue.nextTick</code>获取到改变之后的DOM。</li>
</ul>
</li>
</ul>
<p>总结：</p>
<blockquote>
<p>同步代码执行 -&gt; 查找异步队列，推入执行栈，执行Vue.nextTick[事件循环1] -&gt;查找异步队列，推入执行栈，执行Vue.nextTick[事件循环2]…</p>
<p>总之，异步是单独的一个tick，不会和同步在一个 tick 里发生，也是 DOM 不会马上改变的原因。</p>
</blockquote>
<h2 id="解决问题（应用场景）"><a href="#解决问题（应用场景）" class="headerlink" title="解决问题（应用场景）"></a>解决问题（应用场景）</h2><p>假设一个场景要实现以下需求：</p>
<p><a href="https://sbimg.cn/image/mls2m" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/05/12/QQ20200512160954.jpg" alt="QQ20200512160954.jpg"></a></p>
<p>当我点击<code>+New Tag</code>按钮时，这个按钮会变成一个输入框，并且<strong>自动获取焦点</strong>，如下：</p>
<p><a href="https://sbimg.cn/image/mluM4" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/05/12/QQ20200512161255.jpg" alt="QQ20200512161255.jpg"></a></p>
<p>逻辑上的做法是：输入框之前的 属性<code>v-show</code>为false，我们只需要将其改为true，然后再获取输入框的DOM元素，调用原生事件<code>focus()</code>。</p>
<p>错误代码（按正常逻辑）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showsou()&#123;</span><br><span class="line">  <span class="keyword">this</span>.showit = <span class="literal">true</span> <span class="comment">//修改 v-show</span></span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">"keywords"</span>).focus()  <span class="comment">//在第一个 tick 里，获取不到输入框，自然也获取不到焦点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个DOM还没更新我们就调用focus了，肯定没效果。所以我们要让DOM更新完再调用。修改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">showsou()&#123;</span><br><span class="line">  <span class="keyword">this</span>.showit = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"keywords"</span>).focus()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>css/js/媒体资源会阻塞HTML的解析吗?</title>
    <url>/2020/05/15/css-js-%E5%AA%92%E4%BD%93%E8%B5%84%E6%BA%90%E4%BC%9A%E9%98%BB%E5%A1%9EHTML%E7%9A%84%E8%A7%A3%E6%9E%90%E5%90%97/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近有复习到浏览器对CSS、JS、媒体资源文件（图片、音频等）的加载和解析。</p>
<p>当我们解析HTML的时候，遇到上述资源，会不会阻塞HTML解析呢？</p>
<h2 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h2><p><a href="https://sbimg.cn/image/pXVko" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/05/15/3987507-1bfba2f13098339f.jpg" alt="3987507-1bfba2f13098339f.jpg"></a></p>
<p>1、<strong>解析HTML生成DOM树</strong>：渲染引擎首先解析HTML文档，生成DOM树</p>
<p>2、<strong>生成CSSOM树</strong>：无论是内联式、外联是还是嵌入式引入的css样式都会被解析生成CSSOM树。注意，<strong>该步操作与步骤一是并行的</strong></p>
<p>3、<strong>构建Render树</strong>：根据DOM树与CSSOM树生成另一颗用于渲染的Render树。</p>
<p>4、<strong>布局Render树</strong>：然后对渲染树的每个节点进行布局处理，确定再屏幕上显示的位置。当然这一步还包括一些合成层的操作（新建图层处理一些特殊样势，比如说透明度、transform这种）。</p>
<p>5、<strong>绘制Render树</strong>：绘制出一个个节点</p>
<a id="more"></a>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p><strong>当解析HTML时，遇到了link标签，加载对应的css时不会阻塞HTML的解析</strong>。</p>
<p>因为上面有提到，cssom和dom树的构建是并行的，所以不会阻塞解析。</p>
<p><strong>css加载不会阻塞HTML解析，但是会阻塞渲染树生成与页面的渲染</strong></p>
<p>因为上面有提到，渲染树是要结合dom和ccsom才能生成的。ccsom还未完成的话，就会阻塞渲染。</p>
<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><p>区分加载与执行。</p>
<p>加载是获取网络数据“下载下来”，执行是执行JS代码</p>
<h3 id="执行JS代码阻塞HTML的解析"><a href="#执行JS代码阻塞HTML的解析" class="headerlink" title="执行JS代码阻塞HTML的解析"></a>执行JS代码阻塞HTML的解析</h3><p>首先我们要知道，<strong>执行JS代码与解析HTML是互斥的，也就是会阻塞HTML的解析</strong>。</p>
<p>假如有如下的代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span>元素1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> newEle = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span></span><br><span class="line"><span class="actionscript">        newEle.id = <span class="string">"newEle"</span>;</span></span><br><span class="line"><span class="actionscript">        newEle.innerText = <span class="string">"新元素"</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(newEle);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div2"</span>&gt;</span>元素2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div3"</span>&gt;</span>元素3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>最后的顺序是<strong>元素1、新元素、元素2、元素3。</strong></p>
<p>加入JS执行时不阻塞HTML解析，也就是script里的代码执行，同时html叶继续解析下一个div…</p>
<p>那当我们执行script里的代码时，是append到谁的后面去呢？是元素2还是元素3？都有可能</p>
<p><strong>因此这两个操作必须是互斥的，不然会出现这种情况。</strong></p>
<h3 id="defer与async"><a href="#defer与async" class="headerlink" title="defer与async"></a>defer与async</h3><p>当我们为script标签添加defer/async属性时，会使script<strong>异步加载</strong>，意思是不阻塞HTML的解析，异步的去下载JS文件。</p>
<p>那两个属性的区别是什么呢？</p>
<p><strong>答：执行的时机</strong></p>
<p><strong>下载完后，defer会等到HTML解析完后再执行，而async一下载完后就立即执行</strong></p>
<p><a href="https://sbimg.cn/image/pXTEw" target="_blank" rel="noopener"><img src="https://wx2.sbimg.cn/2020/05/15/3987507-a4b5763f7926f299.png" alt="3987507-a4b5763f7926f299.png"></a></p>
<p>绿色表示HTML解析过程，蓝色表示 script 脚本文件的网络读取过程（加载或下载），红色表示执行过程。</p>
<h2 id="媒体资源文件"><a href="#媒体资源文件" class="headerlink" title="媒体资源文件"></a>媒体资源文件</h2><p>媒体资源文件包括图片、音频视频等，遇到这些资源时，<strong>不会阻塞HTML的解析</strong></p>
<p>HTML的解析不依赖于这此媒体资源，这些媒体资源也不会影响当前Dom树的结构，所以，这些媒体资源的加载不会且也没有必要阻塞HTML的解析！</p>
<p><strong>媒体资源可以并行加载</strong>，因为他不阻塞HTML的解析，我遇到一个媒体资源就开网络线程去下载，因而可以并行。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>那介绍上面这些理论有什么用的？</p>
<p>1、可以想一下，一般你的script标签是放在body上面还是下面？一般link标签放在body上面还是下面？</p>
<p>link标签可以放上面，因为css加载并不会阻塞HTML解析。</p>
<p>而script就比较讲究，如果script放上面，那么就会阻塞HTML解析，白屏的时间可能较长，同时，如果此时操作DOM，会出现问题，<strong>因为你拿的DOM元素都还没被解析呢！</strong></p>
<p>所以一般放下面。</p>
<p>2、如果你不知道该放哪，可以了解一下<code>window.ready</code>和<code>window.onload</code></p>
<p><strong>window.ready()</strong> 表示文档结构已经加载完成（<strong>不包含图片等非文字媒体文件</strong>）；</p>
<p><strong>window.onload()</strong> 在页面完全载入后(<strong>包括图片、css文件等等</strong>)执行脚本代码。</p>
<p>也就是说把代码放在上面两个回调中，是必定能够操作dom的，但是图片、css文件是否已经加载好了是有区别。</p>
<h2 id="我遇到的问题"><a href="#我遇到的问题" class="headerlink" title="我遇到的问题"></a>我遇到的问题</h2><p>这里要实现一个需求，也就是利用canvas画出一张图像。</p>
<p>有一个方法叫<code>context.drawImage(img,dx,dy)</code>，可以在canvas是上画出img图像</p>
<p>img是Image对象，dx，dy是画的位置。</p>
<p>代码如下（这段代码放置在了body的下面）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> canvas = getElementById(<span class="string">'mycanvas'</span>)</span><br><span class="line">    <span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new 一个 Image对象</span></span><br><span class="line">    <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">    <span class="comment">// 为img添加src(本地图片)</span></span><br><span class="line">    img.src = <span class="string">'./pig.jpg'</span></span><br><span class="line">    context.drawImage(img,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>乍一看，好像没有问题。</p>
<p>然而，这张图片就是画不出来！</p>
<p>原因正是：<strong>图片作为一个资源请求，在js中加载时，自然也会有一个图片加载的时间。</strong></p>
<p><strong>但是因为没有限制，极大的情况是当图片还没有加载完毕就调用了drawImage，此方法他是不起作用的。</strong></p>
<p><strong>解决方法1</strong>：上面有说<code>window.onload</code>可以保证里面代码执行的时候，图片已经加载，故只要在里面调用<code>context.drawImage(img,dx,dy)</code>。这种做法解决的核心是onload，将图片和drawImage分开加载，img先加载，确保加载完毕以后再使用绘图</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"./pig.jpg"</span>&gt;</span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">　　context.drawImage()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法2</strong>：使用img.onload，等待图片资源加载完了再调用drawImage。<strong>使用img的加载事件，监听图片加载</strong>成功后，再执行canvas的绘图效果.并且这种方法靠谱一些。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">let</span> canvas = getElementById(<span class="string">'mycanvas'</span>)</span><br><span class="line">    <span class="keyword">let</span> context = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new 一个 Image对象</span></span><br><span class="line">    <span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">    <span class="comment">// 为img添加src(本地图片)</span></span><br><span class="line">    img.src = <span class="string">'./pig.jpg'</span></span><br><span class="line">	<span class="comment">// 等待图片加载完成</span></span><br><span class="line">	img.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        context.drawImage(img,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>别再用对象代替Map了</title>
    <url>/2020/05/14/%E5%88%AB%E5%86%8D%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%BB%A3%E6%9B%BFMap%E4%BA%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实没有标题那么夸张，大家根据喜欢与熟练程度自己选用就好。</p>
<p>只是今天博主用对象代替Map被坑了，所以决心再也不偷懒了……</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>其实JS里的对象和Map都可以用来存键值对。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="string">'name'</span>:<span class="string">'养猪大师'</span>,</span><br><span class="line">     num:<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">'name'</span>,<span class="string">'养猪大师'</span>)</span><br><span class="line">map.set(<span class="string">'num'</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>然而有区别，虽然存的都是key-value，但是在对象中，key的类型会被转化为<strong>字符串</strong></p>
<p>但是map的key值不会被转换哦</p>
</blockquote>
<p>同样，我们也可以通过方法，判断容器里是否有某个key</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj[name])&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">true</span>)</span><br><span class="line">&#125;  <span class="comment">// true</span></span><br><span class="line">map.has(<span class="string">'name'</span>) <span class="comment">// true</span></span><br><span class="line">map.has(<span class="string">'num'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是细心的你有没有发现，我少写了一个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj[num])&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你猜猜会输出啥？</p>
<a id="more"></a>

<h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><p>这就是博主今天刷题遇到的坑。</p>
<p>上面这段代码会返回false。</p>
<p><strong>obj的确有num这个属性，然而由于obj[num]会返回value值，也就是0，因此进了else</strong></p>
<p>你也许会恍然大悟，然后觉得这有什么，下次注意就好。</p>
<p>但是这种东西很玄学的，可能你就真没注意到呢？</p>
<p>如果一定要用obj来写，那我推荐用这样的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(obj[num]!==<span class="literal">undefined</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">true</span>)</span><br><span class="line">&#125; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="来做做这道题"><a href="#来做做这道题" class="headerlink" title="来做做这道题"></a>来做做这道题</h2><blockquote>
<p>来源：leetcode:面试题48</p>
<p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>
<p>示例 1:</p>
<p>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p>
<p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p>
<p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。<br>     请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>提示：</p>
<p>s.length &lt;= 40000</p>
</blockquote>
<p>解答可以自行百度，大致思路是 滑动窗口+hash表优化。</p>
<p>然而博主v1.0的版本如何都无法通过：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> head = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> hash = []</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> tail = <span class="number">0</span> ; tail &lt; s.length ;tail++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(hash[s[tail]])&#123;</span><br><span class="line">            head = <span class="built_in">Math</span>.max(head,hash[s[tail]]+<span class="number">1</span>)</span><br><span class="line">       &#125;</span><br><span class="line">       hash[s[tail]] = tail</span><br><span class="line">       max = <span class="built_in">Math</span>.max(tail-head+<span class="number">1</span>,max)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>原因正是，<strong>返回的value的值是0，破坏了我的计划！</strong>，让我整整找了半小时。</p>
<p>老老实实用Map吧</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lengthOfLongestSubstring = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> head = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> max = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">let</span> tail = <span class="number">0</span> ; tail &lt; s.length ;tail++)&#123;      </span><br><span class="line">       <span class="keyword">if</span>(map.has(s[tail]))&#123;</span><br><span class="line">           <span class="comment">// ！！！注意要max</span></span><br><span class="line">            head = <span class="built_in">Math</span>.max(head,map.get(s[tail])+<span class="number">1</span>)</span><br><span class="line">       &#125;</span><br><span class="line">      map.set(s[tail],tail)</span><br><span class="line">      max = <span class="built_in">Math</span>.max(tail-head+<span class="number">1</span>,max)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇！初心与目标</title>
    <url>/2020/05/08/%E5%BC%80%E7%AF%87%EF%BC%81%E5%88%9D%E5%BF%83%E4%B8%8E%E7%9B%AE%E6%A0%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>建立此博客的目的是为了记录一些平常学习中的所学所感。</p>
<h1 id="Flag"><a href="#Flag" class="headerlink" title="Flag"></a>Flag</h1><p>每天学习一点，若干天会推送一篇合集。</p>
<h1 id="阶段"><a href="#阶段" class="headerlink" title="阶段"></a>阶段</h1><p>现阶段双非一本计算机系，正往前端的路上使劲探索……</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC的三种架构</title>
    <url>/2020/05/13/WebRTC%E7%9A%84%E4%B8%89%E7%A7%8D%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><blockquote>
<p>本文参考：</p>
<p><a href="https://www.cnblogs.com/yiyi17/p/12076657.html" target="_blank" rel="noopener">https://www.cnblogs.com/yiyi17/p/12076657.html</a></p>
<p><a href="https://www.cnblogs.com/yjmyzz/p/webrtc-multiparty-call-architecture.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjmyzz/p/webrtc-multiparty-call-architecture.html</a></p>
</blockquote>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>WebRTC 本身提供的是<strong>1 对 1</strong> 的通信模型，在 STUN/TURN 的辅助下，如果能实现 NAT 穿越，那么两个浏览器是可以直接进行媒体数据交换的；如果不能实现 NAT 穿越，那么只能通过 TURN 服务器进行数据转发的方式实现通信。目前来看，Google 开源的用于学习和研究的项目基本都是基于 STUN/TURN 的 1 对 1 通信。</p>
<p>一些多人场景中，倘若想实现多对多，那怎么办？</p>
<h2 id="Mesh架构"><a href="#Mesh架构" class="headerlink" title="Mesh架构"></a>Mesh架构</h2><p>最容易想到的便是，对于多人会议中的每个人，都与剩余的人进行P2P的连接。如下图</p>
<p><img src="https://wx2.sbimg.cn/2020/05/13/-2020-05-13-201611.png" alt="-2020-05-13-201611.png"></p>
<a id="more"></a>

<p>即多个终端两两进行连接，因而形成了网状结构。</p>
<p>该方案的优势：</p>
<p>1、不需要服务器中转服务器（然而一开始的交换信令和NAT穿越还是需要服务器的），实现简单。</p>
<p>2、充分利用了客户端的带宽资源，节省了服务器带宽的资源。</p>
<p>3、由于媒体流信息是端到端传输的，不用中转服务器，因而更加的<strong>隐私、安全</strong></p>
<p>该方案的劣势：</p>
<p>1、对于每一个人来说，都需要给剩下的人每人发一份自己的媒体流，对上行的带宽占用很大（上下行带宽可以理解为上传与下载带宽）。当人多的时候，占用的宽带就会很大。</p>
<p>2、由于是客户本地对媒体流进行解码编码，因此人多的时候对CPU、内存资源会占用很多。</p>
<p>3*、在多人通信时，如果有部分人不能实现 NAT 穿越，但还想让这些人与其他人互通，就显得很麻烦，需要做出更多的可靠性设计。</p>
<h2 id="MCU架构"><a href="#MCU架构" class="headerlink" title="MCU架构"></a>MCU架构</h2><p>MCU架构便是有一个中心的媒体服务器，接受每个共享端的媒体流。在这个服务上，对所有人的媒体流进行解码、混合、编码，再发送给所有人。如下图：</p>
<p><a href="https://sbimg.cn/image/myzk8" target="_blank" rel="noopener"><img src="https://wx1.sbimg.cn/2020/05/13/-2020-05-13-201611.png" alt="-2020-05-13-201611.png"></a></p>
<p>该方案的优势：</p>
<p>1、连接数较少（可以对比一下MCU和MESH的图），对于浏览器的压力较小。</p>
<p>2、<strong>同步</strong>的音视频通讯，也就是所有参加的人看到的是相同的画面，适合多人视频会议。</p>
<p>3*、作为音视频网关，通过解码、再编码可以屏蔽不同编解码设备的差异化，满足更多客户的集成需求，提升用户体验和产品竞争力。</p>
<p>劣势：</p>
<p>1、中间的服务器要干很多的事情，压力很大，需要有较高的配置。</p>
<p>2、会有延迟，因为服务器处理、传输会带来延迟。<strong>与同步的优点是可以共存的，不要想岔了</strong></p>
<p>3、相比MESH架构，牺牲了隐私与安全。</p>
<h2 id="SFU架构"><a href="#SFU架构" class="headerlink" title="SFU架构"></a>SFU架构</h2><p>SFU架构类似于一个媒体流路由器，与MCU不同的是<strong>SFU服务器不用编码混合等等，只需要转发给其他终端</strong></p>
<p><img src="https://wx2.sbimg.cn/2020/05/13/-2020-05-13-202806.png" alt="-2020-05-13-202806.png"></p>
<p>优势：</p>
<p>1、相比于MCU架构，由于是数据包直接转发，不需要编码解码，对服务器CPU资源消耗小。</p>
<p>2、相比于MCU架构，直接转发降低了延迟，提高了实时性。</p>
<p>3*、最后带来了很大的灵活性，能够更好地适应不同的网络状况和终端类型。</p>
<p>劣势：</p>
<p>1、由于是数据包转发，参与人观看多路视频可能会出现不同步。对于相同的视频流，不同的参与人看到的画面可能会不一致。</p>
<p>2、相比MESH架构，牺牲了隐私与安全。</p>
<p>3*、消耗带宽也比较大</p>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>我个人的项目目前正考虑升级架构，升级完成会更新。</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>认清Token的职责</title>
    <url>/2020/05/11/%E8%AE%A4%E6%B8%85Token%E7%9A%84%E8%81%8C%E8%B4%A3/</url>
    <content><![CDATA[<h2 id="Session-Cookie"><a href="#Session-Cookie" class="headerlink" title="Session+Cookie"></a>Session+Cookie</h2><p>我们知道，http是无状态的，但是在应用中我们常常需要保留用户的登陆状态，也就是保持会话。</p>
<p>一般我们采取的方案是cookie+session这一套，具体过程不再赘述，总结几点：</p>
<p><strong>1、cookie的作用域是domain本身以及domain下的所有子域名。也就是说客户端代码和服务器代码运行在同一台服务器上比较好使用，因为cookie是不能跨域名的！！</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;test1.demo.com:8080 与 http:&#x2F;&#x2F;test2.demo.com:8081 之间共享 cookie</span><br></pre></td></tr></table></figure>

<p>注意：test1.demo.com 是 demo.com的子域名</p>
<p><strong>2、服务器端session存在哪？内存还是数据库？当存在内存中时，服务器采用了多台机器负载均衡，怎么办？可以共享内存吗？其次万一服务器这边重启了session会消失吧！当存在数据库中，那么当用户量大的时候，数据库的负担会遍大，同时也需要频繁的读写。</strong></p>
<p><strong>3、可能会遭到CSRF攻击（cookie劫持）</strong></p>
<p>针对上面三个问题，我们可以想想如何解决：</p>
<p>1、用token，可以跨域名。</p>
<p>2、能不能不把session存在服务端，而存在客户端呢？</p>
<p>3、不使用cookie了，不就能避免CSRF了嘛？</p>
<a id="more"></a>

<h2 id="什么是Token"><a href="#什么是Token" class="headerlink" title="什么是Token"></a>什么是Token</h2><p><strong>Token</strong>是服务端生成的一串字符串，以作客户端进行请求的一个<strong>令牌</strong>，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p>
<p>优点：</p>
<p><strong>1、可以跨域名</strong></p>
<p><strong>2、服务端压力小，不用频繁的操作数据库，只要对token进行签名与“解密”</strong></p>
<p><strong>3、规避了CSRF攻击。</strong></p>
<p>以下讨论无状态Token</p>
<blockquote>
<p>注意，所谓无状态Token就是服务端不存储Token，而让客户端存储。</p>
</blockquote>
<p>你可能想问，如果服务端不存，那怎么验证Token呢？</p>
<blockquote>
<p>假设我用这个数据<code>{id:12345}</code>生成一个<code>token</code>,这个<code>token</code>分为三段信息：</p>
<p>第一段是头部<code>Header</code>，包括的信息有签名使用的算法（HS256等）、令牌的类型等。</p>
<p>第二部分就是我们的数据<code>Payload</code>通过<code>base64</code>加密。包括发行人、到期时间、发布时间以及自定义字段等数据。</p>
<p>第三部分是加密的签名。通过<code>Header</code>和<code>Payload</code>以及我们的服务端的私钥生成。签名是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。</p>
</blockquote>
<p>因此，当服务端发回Token时，<strong>服务端再次对第一二部分进行数字签名，与第三部分对比</strong>。由于服务器私钥我们认为他是安全的，别人无法获得，因此当这两个值是一样的，则我们可以认为<strong>用户的登录信息没有被篡改。</strong>因此完成了Token的验证。</p>
<p>综上，Token的作用是<strong>验证身份</strong>，<strong>安全问题不在它本身的职责范围内</strong></p>
<h2 id="非常容易搞混的点"><a href="#非常容易搞混的点" class="headerlink" title="非常容易搞混的点"></a>非常容易搞混的点</h2><p>这个点便是<strong>安全问题。</strong></p>
<p>你可能会想，倘若我发起<strong>中间人攻击</strong>：我截取了服务端返回的Token值，那么我便可以伪造真实的用户做一些坏事。</p>
<p>没错，的确会这样，然而这不是Token的问题，你想，就算用cookie+session难道不会遇到这种问题嘛？</p>
<p>那怎么办？</p>
<p>事实上，这是<strong>HTTPS中的SSL/TLS防止的事情</strong>：通过对计算机中的网络流量进行加密（密钥协商是通过SSL握手协商而得），就算截取到了这个密文也无法进行破解，除非它们能够以某种方式获取服务器的私有SSL密钥的副本（不太可能）。</p>
<p>同样还有一些别的安全防范手段：</p>
<p>比如就不想别人知道<code>token</code>里面的数据，那就可以在给这个数据加一下密。或者担心这个<code>token</code>会被别人获取，照成这个用户的损失,那就需要在加别的手段来保证，比如通过验证来访的 ip ，比如设置更短的过期时间，比如你用的<code>HTTPS</code>，或者添加更多的验证等等。通过增加第三方的窃取成本，来降低被窃取的几率！</p>
<p>这便是风控手段。</p>
<p>用一个形象的例子来解释：</p>
<blockquote>
<p>你可以把<code>token</code>想象为银行的验钞机,验钞机的职责是验证假钞保证收进来的钱都是真钱，至于这个钱是偷的抢的,还是正常交易，那就不是验钞机管的了，那是警察叔叔管的。</p>
</blockquote>
<h2 id="扯床单"><a href="#扯床单" class="headerlink" title="扯床单"></a>扯床单</h2><p>什么叫扯床单？就是当你铺床时，左边的床单没平，于是你用力一拉…左边的床单是平了，然而右边又乱了……</p>
<p><strong>Token规避了CSRF攻击，然而却增加了XSS攻击的风险</strong></p>
<p>Token一般我们存在哪里？对！客户端。那客户端的哪里？</p>
<p>存在cookie里吗？那本质上是不是又和cookie+session一样了？会造成token版的“CSRF”攻击吧。</p>
<p>一般我们存在<strong>WebStorage</strong>里，比如<strong>LocalStorage、SessionStorage</strong>里。</p>
<p>这两个值是不会像cookie一样被自动携带访问某些网站的。</p>
<p><strong>然而</strong>，这两个值是可以被JavaScript访问的，也就是说，仍然会有XSS攻击的风险！</p>
]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>如何求解async await promise setTimeout的顺序？</title>
    <url>/2020/05/09/%E5%A6%82%E4%BD%95%E6%B1%82%E8%A7%A3async-await-promise-setTimeout%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端笔试题中常常有一种题，给定一定代码，让笔试者写这段代码的输出。一般这段代码，尝尝糅合了各种异步操作，比如async、await、promise、setTimeout，常常令人混淆。与此同时，由于node环境与浏览器环境执行这些异步操作的策略不同，也会有一些差异。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>重要概念：</strong></p>
<ul>
<li>首先我们要知道Javascript是<strong>单线程</strong>的</li>
<li>Javascript里的代码可以分为<strong>同步任务</strong>与<strong>异步任务</strong></li>
<li>同步任务会在<strong>主线程</strong>上执行。是在栈中执行，先进后出。</li>
<li>而异步任务会被放置到主线程之外的<strong>任务队列</strong>，先进先出</li>
<li>当主线程上的同步任务执行完成后，会读取任务队列的异步任务</li>
</ul>
<p><strong>宏任务与微任务</strong></p>
<p>上面讲到异步任务会在任务队列中执行。而执行异步代码的时候会分为两个队列，宏任务队列与微任务队列。</p>
<p>宏任务包括：</p>
<ul>
<li>一开始执行的整段的代码（script代码）</li>
<li>setTimeout、setInterval、postMessage等</li>
</ul>
<p>微任务包括：</p>
<ul>
<li><p>Promise.then后面的代码</p>
</li>
<li><p>await后面的代码（指的是 await func() 下一行开始的代码）</p>
</li>
<li><p>process.nextTick（node中的）</p>
<a id="more"></a>

</li>
</ul>
<h2 id="浏览器与Node中的事件轮询策略"><a href="#浏览器与Node中的事件轮询策略" class="headerlink" title="浏览器与Node中的事件轮询策略"></a>浏览器与Node中的事件轮询策略</h2><ul>
<li><p>对于<strong>浏览器</strong>来说，同步代码在栈中执行完毕后，会<strong>先去执行微任务队列</strong>，将微任务队列<strong>执行完</strong>后，<strong>再去执行宏任务队列</strong>。当每个宏任务被执行完后，准备执行下一个宏任务时，会检查这个执行完的宏任务是否产生了新的微任务。如果产生了新的微任务，则先去清空微任务队列，再执行下一个宏任务。依次轮循，直到清空整个异步队列。</p>
</li>
<li><p>对于<strong>Node</strong>来说。同样会现在栈中执行同步代码，不同的是Node有自己的多个处理不同问题的阶段和对应的队列，整个事件轮询机制是Libuv库实现的。与浏览器最大的不同是Node中有<strong>多个队列，分别执行不同操作</strong>。在每次<strong>队列切换</strong>时，都会区<strong>清空一次微任务队列</strong>。</p>
<p><img src="https://i.loli.net/2020/05/09/YwG4j9gW7T1fsev.png" alt="批注 2020-05-09 205449.png"></p>
</li>
</ul>
<p><strong>总结</strong>：Node会在队列切换时清空微任务队列，意思是这个队列可能会产生很多微任务，然而也要等这个队列执行完后再去清空这些微任务。然而浏览器会再产生微任务后，就去执行微任务，然后再执行下一个宏任务。</p>
<p><strong>举例</strong>：看如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout1"</span>);</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Promise1"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"setTimeout2"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>对于Node来说</p>
<p>1、将整段代码看作宏任务，解析时将两个setTimeout放入timers队列，而console.log(1)为同步任务，会输出1</p>
<p>2、此时检查微任务队列，发现微任务队列为空，切换到下一个队列</p>
<p>3、进入了timers队列，解析第一个setTimeout，发现有 console.log(“setTimeout1”)，输出setTimeout1。</p>
<p>4、发现有Promise.then，将里面的内容放入微任务队列</p>
<p><strong>5、解析第二个setTimeout队列，发现有console.log(“setTimeout2”);，输出setTimeout2</strong></p>
<p><strong>6、timers队列解析完毕，即将队列切换，检查微任务队列，发现有Promise.then，输出Promise1。</strong></p>
<p>对于浏览器来说</p>
<p>1、将整段代码看作宏任务，解析时将两个setTimeout放入宏任务队列，而console.log(1)为同步任务，会输出1</p>
<p>2、此时微任务队列为空，进入宏任务队列</p>
<p>3、解析第一个setTimeout，发现有发现有 console.log(“setTimeout1”)，输出setTimeout1。</p>
<p>4、发现有Promise.then，将里面的内容放入微任务队列</p>
<p><strong>5、因为产生了新的微任务，故执行完上一个宏任务后，立马清空微任务，输出Promise1</strong></p>
<p><strong>6、微任务执行完毕，继续执行第二个setTimeout，输出setTimeout2</strong></p>
<h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请写出输出内容</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"> </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">async1();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*浏览器中</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">setTimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这段代码加了几乎所有”难点”难点</p>
<p><strong>注意：遇到 await 会跳出当前函数，并让出线程，再将await后面的代码放到 微任务（microtask）队列中</strong>。</p>
<p>执行过程为</p>
<p>1、同步执行, 输出“script start”。</p>
<p>2、遇到setTimeout，将里面代码放到宏任务队列。</p>
<p>3、继续往下，输出 “async1 start”，然后执行 async2函数，输出 “async2”。</p>
<p>4、async2执行完毕，<strong>将await async2 后面的代码（console.log(‘async1 end’);）加入到 微任务队列</strong></p>
<p>5、aysnc1()流程走完了，接下来进到Promise，同步输出’promise1’</p>
<p>6、遇到 <strong>promise.then，加入到微任务队列</strong></p>
<p>7、同步输出script end</p>
<p>8、当前宏任务执行完毕，查看微任务队列，按照先进先出原则</p>
<p>9、依次输出’async1 end’ “promise2”</p>
<p>10、执行下一个宏任务，里面只有一个setTimeout，所以最后输出setTimeout</p>
<p><strong>同步执行的：[script start] [async1 start] [async2] [promise1] [script end]</strong></p>
<p><strong>微任务队列：[async1 end] [ promise2 ]</strong></p>
<p><strong>宏任务队列：[setTimeout]</strong></p>
<blockquote>
<p>参考</p>
<p><a href="https://www.cnblogs.com/ly0612/p/setTimeout-promise-async-await-js-JavaScript.html" target="_blank" rel="noopener">https://www.cnblogs.com/ly0612/p/setTimeout-promise-async-await-js-JavaScript.html</a></p>
<p><a href="https://www.jianshu.com/p/c620ece29586" target="_blank" rel="noopener">https://www.jianshu.com/p/c620ece29586</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>异步</tag>
      </tags>
  </entry>
  <entry>
    <title>图片懒加载与防抖节流</title>
    <url>/2020/05/10/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>图片懒加载是一种比较常见的优化方式，其效果是当用户拉动滚动条到图片位置时，图片才开始加载（未加载之前会用一张默认图片代替），这样可以有效地防止所有图片集中请求加载，造成拥堵。</p>
<p>下图是建议的效果，当拉动滚动条到当前加载的图片的最后一张时，会发现下一张还未加载。</p>
<p>然而继续往下拉动后，这张图片会进行加载</p>
<p><img src="https://wx2.sbimg.cn/2020/05/10/MDTCPC1OMCGBM_WHPX.png" alt="MDTCPC1OMCGBM_WHPX.png"></p>
<a id="more"></a>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>其实主要的思想与我之前的文章<a href="https://www.pigkeeper.xyz/2020/05/09/瀑布流效果/" target="_blank" rel="noopener">纯JS瀑布流效果与动态加载</a>里的动态加载非常的相似，都是计算一个滚动的阈值，达到这个阈值后便进行图片的加载。</p>
<p><strong>首先我们搭建简单的html结构</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./default.png"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">data-src</span>=<span class="string">"./images/0.jpg"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，img的src属性都是”./default.png”，这是一张默认图，也就是上图的蓝色图片，而图片真正的src存在data-src中。data-src是一个自定义的数据，当我们获取到某个img的dom节点对象时，我们可以通过一些语句来获得data-src的值，方法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(img.dataset.src)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会输出data-src的内容</span></span><br></pre></td></tr></table></figure>

<p><strong>其次是css</strong></p>
<p>这里只是限定图片的大小，并居中显示</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">        <span class="selector-tag">img</span> &#123;</span><br><span class="line">            <span class="attribute">width</span>: <span class="number">230px</span>;</span><br><span class="line">            <span class="attribute">height</span>: <span class="number">320px</span>;</span><br><span class="line">            <span class="attribute">display</span>: block;</span><br><span class="line">            <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.box</span> &#123;</span><br><span class="line">            <span class="attribute">display</span>: flex;</span><br><span class="line">            <span class="attribute">flex-direction</span>: column;</span><br><span class="line">            <span class="attribute">align-items</span>: center;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>js部分</strong></p>
<p>至此，我们很容易的想到，如果要实现图片的懒加载，我们只需要监听滚动事件，当触发某个条件时，我们就把img标签的src属性值替换为data-src的值，这样就能加载图片了。</p>
<p>那么，这个条件是什么呢？</p>
<p>同样用一张图来说明：</p>
<p><img src="https://wx2.sbimg.cn/2020/05/10/1.png" alt="1.png"></p>
<p>其中offsetTop、halfHeight、clientHeight都不会变，只有scrollTop会变</p>
<p>故当<strong>offsetTop + halfHeight &lt; scrollTop + clientHeight</strong>时，加载图片。</p>
<p><strong>以下是完整代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有的img节点</span></span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span><br><span class="line">    <span class="comment">// 将伪数组转化为数组</span></span><br><span class="line">    img = [...img]</span><br><span class="line">    img.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 图片高度的一半</span></span><br><span class="line">        <span class="keyword">let</span> halfHeight = <span class="built_in">Math</span>.floor(element.clientHeight / <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (element.offsetTop + halfHeight &lt; <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">            <span class="comment">// 替换src</span></span><br><span class="line">            element.src = element.dataset.src</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>至此，基本完成了图片的懒加载。</p>
<h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><blockquote>
<p> 在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p>
<p>一般可以用防抖和节流来解决这个问题。</p>
</blockquote>
<p><strong>防抖（debounce）</strong></p>
<p><strong>所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间，用定时器实现。</strong></p>
<p>下面是具体的实现，注意看我的注释。闭包是为了保留timer这个状态，而apply的作用在注释中有写到，可以仔细去品味一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 闭包</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// !!!!很重要</span></span><br><span class="line">    <span class="comment">// 这个函数是事件对象调用的函数，事件会给这个函数一个参数e 下面可以用arguments拿到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">            clearInterval(timer)</span><br><span class="line">        &#125;</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 由于是箭头函数，这个this和arguments是从上面继承下来的</span></span><br><span class="line">            <span class="comment">// 用apply是为了让 debounce 函数最终返回的函数 this 指向不变以及依旧能接受到 e 参数。</span></span><br><span class="line">            <span class="comment">// 这个arguments就是 e</span></span><br><span class="line">            fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>节流（throttle）</strong></p>
<p><strong>所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。</strong></p>
<p>懂了防抖，节流也会相对容易理解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">return</span></span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            func.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">            flag = <span class="literal">true</span></span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图片懒加载的优化"><a href="#图片懒加载的优化" class="headerlink" title="图片懒加载的优化"></a>图片懒加载的优化</h2><p>上面我们实现的懒加载，是依靠监听滚动条。当我们滚动时，会频繁的触发计算，是否可以优化，让它少触发几次？那我们是应该用防抖还是节流呢？</p>
<p>想一下，如果用防抖，会导致一直触发事件，一直重置定时器，是不是有可能一直加载不出图片？</p>
<p>而用节流，无论你在这段时间里触发多少次，过了这段时间我一定会执行一次，这是不是就满足了我们的需求！</p>
<p>注意书写形式</p>
<p><strong>完整代码</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滚动条用节流比较好</span></span><br><span class="line"><span class="built_in">window</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> img = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>)</span><br><span class="line">    <span class="comment">// console.log(img)</span></span><br><span class="line">    img = [...img]</span><br><span class="line">    img.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> halfHeight = <span class="built_in">Math</span>.floor(element.clientHeight / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (element.offsetTop + halfHeight &lt; <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">            element.src = element.dataset.src</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考：<a href="https://www.jianshu.com/p/c8b86b09daf0" target="_blank" rel="noopener">https://www.jianshu.com/p/c8b86b09daf0</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>图片懒加载 节流 防抖</tag>
      </tags>
  </entry>
  <entry>
    <title>纯JS瀑布流效果与动态加载</title>
    <url>/2020/05/09/%E7%80%91%E5%B8%83%E6%B5%81%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>瀑布流效果的特征是，里面的图片<strong>等宽不等高</strong>，并按列向下排列。同时，也可以拥有<strong>动态加载</strong>的功能。</p>
<p>可以参考<a href="https://www.mogu.com/" target="_blank" rel="noopener">蘑菇街</a>首页的效果</p>
<p>在社区中也有许多的瀑布流库可以使用，本文主要采用<strong>纯JS</strong>实现。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>主要是通过<strong>绝对布局</strong>的方法对每一个图片盒子进行定位，通过JS计算出每一张图片对应的<strong>left和top属性</strong></p>
<p>计算出每一个图片盒子的定位后，通过监听<strong>滚轮事件</strong>，<strong>判断</strong>是否要进行动态加载新的图片</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ul>
<li><p><strong>首先搭建基本的html结构</strong></p>
<p>以下就是一个图片盒子的基本单元，我们复制40次这个单元以充满首屏。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./images/0.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p><strong>css中为图片限定尺寸并使用绝对定位</strong></p>
<p>去掉所有的padding和margin</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把body设置为relative，使得图片盒子的绝对定位是基于body的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后为每一个图片限定尺寸，高度设为auto是为了让图片自适应，不要忘记原则是<strong>图片等宽不等高</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">230px</span>;</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>最重要的JS部分！</strong></p>
<ul>
<li><p>首先确定浏览器的显示区域内，一行能放多少个图片盒子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列数 = 页宽 / 每一个图片盒子的宽度，记得要进行取整</span></span><br><span class="line"> <span class="keyword">let</span> pageWidth = <span class="keyword">this</span>.document.body.clientWidth</span><br><span class="line"> <span class="keyword">let</span> boxWidth = <span class="number">230</span></span><br><span class="line"> <span class="keyword">let</span> colNum = <span class="built_in">Math</span>.floor(pageWidth / (boxWidth + <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<p>此时我们得到了在当前浏览器显示区域的大小内，我们能够显示<em>colNum</em>列</p>
</li>
<li><p>我们先排第一行元素，假设我们算出来当前的<em>colNum</em>为4</p>
<p>如下图所示，其中gap为两张图片之间的空隙：</p>
<p><img src="https://i.loli.net/2020/05/09/rgqvVwUpJISHMZO.png" alt="图片1.png"></p>
</li>
</ul>
</li>
</ul>
<pre><code>我们可以轻易的得出 第一行的图片top都为0

第一张图片的 left = （boxWidth  +  gap）*0

第二张图片的 left = （boxWidth  +  gap）*1

第三张图片的 left = （boxWidth  +  gap）*2

第四张图片的 left = （boxWidth  +  gap）*3

我们获取所有的box形成boxs数组，因此我们可以对第一行进行排列：

其中的*colHeigth*是一个数组，维护每一列的高度。每一列的高度=这一列所有图片的总和加上间隙。

这个*colHeight*数组是后续图片排序的重要依据！

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxs.length; i++) &#123;</span><br><span class="line">          <span class="comment">// 先排列第一行</span></span><br><span class="line">          <span class="keyword">if</span> (i &lt; colNum) &#123;</span><br><span class="line">              boxs[i].style.cssText = <span class="string">`left:<span class="subst">$&#123;i * (boxWidth + gap)&#125;</span>px`</span></span><br><span class="line">              colHeight.push(boxs[i].clientHeight)</span><br><span class="line">        &#125;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>当我们需要排列第五张图片时</p>
<p>第五张图片需要放在哪呢？放在<strong>当前高度最小的所在列的下面</strong></p>
<p>如下图，在第一行排完后，第三张图片所在列的高度最小，故第五张图片就排在第三列的下面！</p>
<p><img src="https://i.loli.net/2020/05/09/VNxpL4k5Ss89T1v.png" alt="图片2.png"></p>
<p>故第五张图片的top = 第三张图片的高度 + 间隙； left = 第三张图片的left值</p>
<p>排完后，我们要更新<em>colHeight</em>对应列的高度，也就是把原先第三列的高度加上第五张图片的高度和gap。</p>
<p>第五张、第六张……都可以这么做。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxs.length; i++) &#123;</span><br><span class="line">       <span class="comment">// 先排列第一行</span></span><br><span class="line">       <span class="keyword">if</span> (i &lt; colNum) &#123;</span><br><span class="line">          boxs[i].style.cssText = <span class="string">`left:<span class="subst">$&#123;i * (boxWidth + gap)&#125;</span>px`</span></span><br><span class="line">          colHeight.push(boxs[i].clientHeight)</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// 从第二行开始，找当前高度最短的列</span></span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> minHeight = <span class="built_in">Math</span>.min(...colHeight)</span><br><span class="line">          <span class="keyword">let</span> minIndex = colHeight.indexOf(minHeight)</span><br><span class="line">          boxs[i].style.cssText = <span class="string">`top:<span class="subst">$&#123;minHeight + 		                                     gap&#125;</span>px;left:<span class="subst">$&#123;boxs[minIndex].offsetLeft&#125;</span>px`</span></span><br><span class="line">          colHeight[minIndex] += (boxs[i].clientHeight + gap)</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>至此，已经完成了瀑布流的基本布局。</p>
<p>完整代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> boxs = <span class="keyword">this</span>.document.getElementsByClassName(<span class="string">'box'</span>)</span><br><span class="line"><span class="keyword">let</span> waterfall = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 确定浏览器显示区域内，一行能放多少列图片盒子</span></span><br><span class="line">    <span class="keyword">let</span> pageWidth = <span class="keyword">this</span>.document.body.clientWidth</span><br><span class="line">    <span class="keyword">let</span> boxWidth = <span class="number">230</span></span><br><span class="line">    <span class="keyword">let</span> gap = <span class="number">7</span></span><br><span class="line">    <span class="keyword">let</span> colNum = <span class="built_in">Math</span>.floor(pageWidth / (boxWidth + <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">let</span> colHeight = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; boxs.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 先排列第一行</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; colNum) &#123;</span><br><span class="line">            boxs[i].style.cssText = <span class="string">`left:<span class="subst">$&#123;i * (boxWidth + gap)&#125;</span>px`</span></span><br><span class="line">            colHeight.push(boxs[i].clientHeight)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第二行开始，找当前高度最短的列</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> minHeight = <span class="built_in">Math</span>.min(...colHeight)</span><br><span class="line">            <span class="keyword">let</span> minIndex = colHeight.indexOf(minHeight)</span><br><span class="line">            boxs[i].style.cssText = <span class="string">`top:<span class="subst">$&#123;minHeight + gap&#125;</span>px;left:<span class="subst">$&#123;boxs[minIndex].offsetLeft&#125;</span>px`</span></span><br><span class="line">            colHeight[minIndex] += (boxs[i].clientHeight + gap)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><ul>
<li><p>实现改变窗口大小时，布局变化（列数）</p>
<p>很简单，只要监听resize事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听resize事件</span></span><br><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    waterfall()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现动态加载</p>
<p>原理如下图，绿色图片盒子是当前boxs数组中的最后一个元素，当用户滚动滚动条，绿色元素显示出来，我们就需要加载新的图片了。</p>
<p>其中offsetTop、clientHeight是不会变化的，只有scrollTop会随着滚动条的滚动而增加。故临界条件是</p>
<p><strong>offsetTop &lt;  ScrollTop + clientHeight</strong> 时，就要加载新的图片</p>
<p><img src="https://i.loli.net/2020/05/09/Db9REgoVziN7tu8.png" alt="图片3.png"></p>
</li>
</ul>
<p>​    这里使用一个数组来模拟新的图片</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">        <span class="string">'./images/19.jpg'</span>,</span><br><span class="line">    	...</span><br><span class="line">    ]</span><br><span class="line"><span class="built_in">window</span>.onscroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (boxs[boxs.length - <span class="number">1</span>].offsetTop + <span class="built_in">Math</span>.floor(boxs[boxs.length - <span class="number">1</span>].clientHeight / <span class="number">2</span>) &lt; <span class="built_in">document</span>.documentElement.scrollTop + <span class="built_in">document</span>.documentElement.clientHeight) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">                <span class="comment">// 创建图片盒子单元</span></span><br><span class="line">                <span class="keyword">let</span> div = <span class="keyword">this</span>.document.createElement(<span class="string">'div'</span>)</span><br><span class="line">                div.className = <span class="string">'box'</span></span><br><span class="line">                <span class="keyword">let</span> img = <span class="keyword">this</span>.document.createElement(<span class="string">'img'</span>)</span><br><span class="line">                img.src = data[i]</span><br><span class="line">                div.appendChild(img)</span><br><span class="line">                body = <span class="keyword">this</span>.document.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]</span><br><span class="line">                body.appendChild(div)</span><br><span class="line">                <span class="comment">// 追加到boxs数组中</span></span><br><span class="line">                boxs = <span class="keyword">this</span>.document.getElementsByClassName(<span class="string">'box'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            waterfall()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​    至此，完成了动态加载，下拉即可触发</p>
<p><img src="https://i.loli.net/2020/05/09/4v5P76aiXuL3hnM.png" alt="批注 2020-05-09 103755.png"></p>
]]></content>
      <tags>
        <tag>瀑布流 JS</tag>
      </tags>
  </entry>
</search>
